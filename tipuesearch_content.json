{"pages":[{"url":"http://wonux.github.io/about.html","text":"关于Wonux名字： 解一：Mr Wong's UX system\". \"Won\"取自王姓\"Wong\"，另外\"Wo\"拼音\"我\"之意，即我的 UX 系统( UNIX - LIKE )使用心得之意。 解二：业余Linux爱好者，就职中国联通，受启发于\"沃\"品牌，\"Wo\"为山河日月，无限宽广之意。 解三：本人姓\"王\"，网名\"孤逐王\"，Wonux致敬Linus，嘿嘿。 关于本站内容： Put the fun back into computing.Use Linux, BSD . 关于作者： 微博: weibo.com/wonux Email: wonux@qq.com Github: github.com/wonux 开源静态博客: Github Pages: wonux.github.io ; Coding Pages: wonux.coding.me 博客园: www.cnblogs.com/wonux CSDN : blog.csdn.net/wonux 豆瓣: https://www.douban.com/people/wonux/ 豆瓣小站: https://site.douban.com/271881/","tags":"Misc","title":"About"},{"url":"http://wonux.github.io/git-empty-branch.html","text":"有时候需要在项目中创建一个空白的新分支，来开发测试与当前分支内容无关的内容。向分支提交一个初始的空commit，保证完全复位。 创建并切换新分支 1 2 3 4 git branch <new_branch> git checkout <new_branch> git rm --cached -r . git clean -f -d 创建空的commit 1 git commit --allow-empty -m \"[empty] initial commit\" 推送新分支 1 git push origin <new_branch>","tags":"Git","title":"Git创建空白新分支"},{"url":"http://wonux.github.io/git-remote.html","text":"在已经习惯使用git同步写代码，github无疑是最的托管平台，但是国内由于\"你懂的\"原因，速度很慢，有时无法访问，于是想把自己的代码同步到多个不同的远程仓库备份。 我的主要仓库: [github] https://github.com/wonux.test.git 主仓库 [oschina] https://git.oschina.net/wonux/test.git 国内常用仓库 另外，国内还有coding(原来的gitcafe合并到了coding),csdn code等。 添加同名多个远程仓库 添加一个remote,这里是all,也可以是别的名字(如origin) 1 git remote add all https://github.com/wonux.test.git 再添加另一个: 1 git remote set-url --add all https://git.oschina.net/wonux/test.git 重复向同一个远程仓库名字添加需要 set-url --add 参数 如果有多个,按照上面这一个命令进行添加. 向多远程仓库推送代码 1 git push all --all 这样就会一次提交到多个库了,上面命令输出如下: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 git push all -- all Username for ' https : //github.com': wonux Password for ' https : //wonux@github.com': Counting objects : 68 , done . Delta compression using up to 4 threads . Compressing objects : 100 % ( 56 / 56 ), done . Writing objects : 100 % ( 68 / 68 ), 72.16 KiB | 0 bytes / s , done . Total 68 ( delta 13 ), reused 0 ( delta 0 ) To https : //github.com/wonux/test.git * [ new branch ] master -> master Username for ' https : //git.oschina.net': wonux Password for ' https : //wonux@git.oschina.net': Counting objects : 68 , done . Delta compression using up to 4 threads . Compressing objects : 100 % ( 56 / 56 ), done . Writing objects : 100 % ( 68 / 68 ), 72.16 KiB | 0 bytes / s , done . Total 68 ( delta 13 ), reused 0 ( delta 0 ) To https : //git.oschina.net/wonux/test.git * [ new branch ] master -> master 记住不要忘记 --all 参数，如果不加 --all ，则无法推送，提示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 git push all warning : push .default is unset ; its implicit value has changed in Git 2 .0 from 'matching' to 'simple' . To squelch this message and maintain the traditional behavior , use : git config --global push .default matching To squelch this message and adopt the new behavior now , use : git config --global push .default simple When push .default is set to 'matching' , git will push local branches to the remote branches that already exist with the same name . Since Git 2 .0 , Git defaults to the more conservative 'simple' behavior , which only pushes the current branch to the corresponding remote branch that 'git pull' uses to update the current branch . See 'git help config' and search for 'push.default' for further information . ( the 'simple' mode was introduced in Git 1 .7.11 . Use the similar mode 'current' instead of 'simple' if you sometimes use older versions of Git ) fatal : unable to access 'https://github.com/wonux/test.git/' : Couldn 't resolve host ' github .com ' 分析配置文件 在操作完上面的添加命令后，如果我们打开 .git/config 文件,我们可以看到这样的配置: 1 2 3 4 [remote \"all\"] url = https://github.com/wonux/test.git fetch = +refs/heads/*:refs/remotes/all/* url = https://git.oschina.net/wonux/test.git 因此，直接在 .git/config 文件中添加： 1 2 3 4 [remote \"all\"] url = https://github.com/wonux/test.git fetch = +refs/heads/*:refs/remotes/all/* url = …… 有多少个远程库,就配置多少个url即可. 从这里可以看出,第一种方法生成的配置中还有一个fetch配置,这个配置可以完全去掉.","tags":"Git","title":"Git同时提交到多个远程仓库"},{"url":"http://wonux.github.io/apps-doubanfm.html","text":"douban.fm Terminal-based douban.fm inspired by douban.fm .该版本版基于Python2.* 安装Python2.* 1 2 pacman -S python2 pacman -S python2-pip 安装douban.fm 1 pip2 install douban.fm 需要mplayer播放器依赖,如未安装: 1 pacman -S mplayer Update 1 pip2 install --upgrade douban.fm Usage 在终端下直接输入 1 douban.fm 第一次登陆需要输入账号,密码,程序不会保留密码,而是保存返回的token存储在~/.douban_token.txt,下次登陆无需输入密码. Keys 支持vim按键 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 移动 [j] --> 下 [k] --> 上 [g] --> 移到最顶 [G] --> 移到最底 音乐 [space] --> 播放 [w] --> 打开歌曲专辑豆瓣主页 [n] --> 下一首 [r] --> 喜欢/取消喜欢 [b] --> 不再播放 [q] --> 退出 [p] --> 暂停 [l] --> 单曲循环 音量 [=] --> 增 [-] --> 减 [m] --> 静音 [e] --> 播放/历史/红心列表 歌词 [o] --> 显示歌词 [q] --> 退出歌词 帮助 [h] --> 查看快捷键 主题 [1] [2] [3] [4] github主页： douban.fm","tags":"Applications","title":"Shell终端收听音乐—豆瓣 FM 命令行版"},{"url":"http://wonux.github.io/gentoo-arch-apps.html","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 ## Desktop Environment ### GNOME ### KDE ### LXDE ### Xfce ## Window Managers ### dwm [x11-wm/dwm] [dmenu] euse --enable savedconfig ln -s /etc/portage/savedconfig/x11-wm/dwm-6.1 /etc/portage/savedconfig/x11-wm/dwm-6.1.h ### Awesome ### openbox x11-wm/openbox [obconf] [obmenu] [tint2] [dmenu_run] .config/openbox/ autostart menu.xml rc.xml ## Taskbars/Panels ### lxpanel ### tint2 [tint2] [volumeicon] .config/tint2/tint2rc ### wbar ## Desktop Utilities ### File Managers #### vifm #### xfe #### dolphin #### thunar #### pcmanfm ### Clipboard Managers ### Terminal Emulators #### rxvt-unicode [x11-terms/rxvt-unicode] [xorg-xrdb] [x11-misc/xsel] [x11-misc/xclip] [x11-misc/urxvt-perls] .Xresources .xinitrc == [[ -f ~/.Xresources ]] && xrdb -merge ~/.Xresources urxvtd --quiet --opendisplay --fork == urxvtc #### tilda #### sakura #### xfce4-terminal #### konsole #### yakuake #### lxterminal ## Network Management ### dhcpcd ### wpa_supplicant ### networkmanager ### netctl ## Internet ### Email Clients ### P2P #### rtorrent ### Web Browsers #### firefox #### chromium #### midori ## Multimedia ### Audio #### MPD #### moc ### Video #### mplayer ### Image Viewers #### xfe #### xfi ## Documents ### Editors #### vim ### Document Readers #### zathura #### apvlv #### mupdf ### Office Suites #### wps-office 参考： https://wiki.gentoo.org/wiki/Rxvt-unicode https://wiki.archlinux.org/index.php/Rxvt-unicode","tags":"Gentoo","title":"Gentoo/Arch常用软件列表"},{"url":"http://wonux.github.io/apps-rsync.html","text":"rsync介绍 rsync , Remote Synchronize 顾名思意它是一款实现远程同步功能的软件，可通过 LAN / WAN 快速同步多台主机间的文件。它在同步文件的同时，可以保持原来文件的权限、时间、软硬链接等附加信息。Rsync使用所谓的 \"Rsync算法\"来使本地和远程两个主机之间的文件达到同步，这个算法只传送两个文件的不同部分，而不是每次都整份传送，因此速度相当快，而且可以通过ssh方式来传输文件，这样其保密性也非常好，另外它还是免费的软件。 Rsync是一款通过网络备份重要数据的工具/软件。它同样是一个在类Unix和Window系统上通过网络在系统间同步文件夹和文件的网络协议。Rsync可以复制或者显示目录并复制文件。Rsync默认监听 TCP 873端口，通过远程shell如rsh和ssh复制文件。Rsync必须在远程和本地系统上都安装。 rsync优点 速度：最初会在本地和远程之间拷贝所有内容。下次，只会传输发生改变的块或者字节。 安全：传输可以通过ssh协议加密数据。 低带宽：rsync可以在两端压缩和解压数据块。 缺点 单向同步，不支持双向传输 特性 可以镜像更新整个目录树和文件系统。 有选择性的保持符号链链、硬链接、文件属于、权限、设备以及时间等； 对于安装来说，无任何特殊权限要求； 对于多个文件来说，内部流水线减少文件等待的延时； 用rsh、ssh 或直接端口做为传输入端口； 支持匿名rsync 同步文件，是理想的镜像工具； 使用 语法 1 rsync [OPTION] SRC_PATH/[SRC_FILE] DEST_PATH 选项 1 2 3 4 5 6 7 8 9 10 11 12 13 -a 以archive模式操作、复制目录、符号连接 相当于-rlptgoD,是保留了所有人和所属组、时间戳、软链接、权限，并以递归模式运行。 -l 是链接文件，意思是拷贝链接文件；-p 表示保持文件原有权限；-t 保持文件原有时间；-g 保持文件原有用户组；-o 保持文件原有属主；-D 相当于块设备文件； -r 是递归 -z 传输时压缩； -P 传输进度； -v 传输时的进度等信息，和-P有点关系，自己试试。可以看文档； -e ssh的参数建立起加密的连接。 -n,--dry-run预览操作，不实际改变文件。 -u, --update仅仅进行更新，也就是跳过所有已经存在于DST，并且文件时间晚于要备份的文件。(不覆盖更新的文件)，注意两者机器的时钟的不同. --progress是指显示出详细的进度情况 --existing 仅仅更新那些已经存在于DST的文件，而不备份那些新创建的文件 --delete 删除那些DST中SRC没有的文件 --password-file=/password/path/file来指定密码文件，这样就可以在脚本中使用而无需交互式地输入验证密码了，这里需要注意的是这份密码文件权限属性要设得只有属主可读。 常用实例 启用压缩 1 rsync -zvr /home/aceking/ /backupdir 保留文件和文件夹的属性 1 rsync -zva /home/aceking/ /backupdir 模拟运行查看结果，不实际操作 1 rsync -zvan /home/aceking/ /backupdir 找出文件间的不同 1 rsync -avzi /backupdir /home/aceking/ 排除文件和目录列表 有时候，当我们做大量同步的时候，我们可能想要从同步的文件和目录中排除一个文件和目录的列表。一般来说，像设备文件和某些系统文件，或者像临时文件或者缓存文件这类占据不必要磁盘空间的文件是不合适同步的，这类文件是我们需要排除的。 创建排除文件 --exclude-from 参数,创建一个名为 excluded 的文件（当然，你想取什么名都可以），将想要排除的文件夹或文件写入该文件，一行一个。例如，如果你想要对根分区进行完整的备份，你应该排除一些在启动时创建的设备目录和放置临时文件的目录： 1 2 3 4 5 6 7 8 9 10 11 12 # cat exclude /dev/* /proc/* /sys/* /tmp/* /run/* /mnt/* /media/* /lost+found # rsync -aAXhv --exclude-from=excluded / /mnt/backup 从命令行排除文件 --exclude 参数,目录列表 {\"/var/cache\",\"/var/tmp\"} 1 rsync -aAXhv --exclude={\"/var/cache\",\"/var/tmp\"} /var /home/adrian/var","tags":"Applications","title":"RSync实现文件备份同步"},{"url":"http://wonux.github.io/arch-kde.html","text":"plasma desktop Install the plasma-meta meta-package or the plasma group. Alternatively, for a more minimal Plasma installation, install the plasma-desktop package. sddm The Simple Desktop Display Manager ( SDDM ) is the preferred display manager for KDE Plasma desktop. Install sddm 1 pacman -S sddm Configuration SDDM defaults to using systemd-logind for session management. 1 sddm --example-config > /etc/sddm.conf Loading sddm 1 2 systemctl start sddm systemctl enable sddm","tags":"Arch","title":"Arch安装 KDE5"},{"url":"http://wonux.github.io/apps-musicbox.html","text":"Musicbox：网易云音乐命令行版本 高品质网易云音乐命令行版本，简洁优雅，丝般顺滑，基于Python编写。 这款命令行的客户端使用 Python 构建，以 mpg123 作为播放后端： 1 2 3 Vim 式的流畅操作，支持快捷键绑定 支持电台、收藏等各种特色功能 支持 OS X 及各类 Linux 发行版 安装Python2.* 1 2 pacman -S python2 pacman -S python2-pip 安装musicbox 1 2 pip2 install NetEase-MusicBox pacman -S mpg123 Usage 在终端下直接输入 1 musicbox 更多详情参考位于 Github 上的项目 参考： Musicbox：网易云音乐命令行版本","tags":"Applications","title":"Shell终端收听音乐—网易云音乐命令行版"},{"url":"http://wonux.github.io/apps-vim.html","text":"使用vim教程 1 vimtutor 它会复制一份教程文件,你可以放心练习,不用担心破坏原来的内容. 求助 :help :help + 相关内容 vim三种工作模式 Normal模式: Esc Insert模式: i a o i:光标前 I:光标行首 a:光标后 A:光标行末 o:光标下新行 O:光标上新行 末行模式: : 定位 h j k l 0 &#94; &#94;行首非空字符 0行首字符 $ 末字符 w W b B e E Enter 移至下行首 gg G 8G 50% H M L zz zt zb f F / ? Ctrl + d 下滚半页 Ctrl + u 上滚半页 Ctrl + f 下滚一页 Ctrl + b 上滚一页 x dw de db d$ dd D 3dd : 5,10d J u U Ctrl + R yy p P :wq :x zz :q :q! 查询信息 当前位围置 Ctrl + G :set number :set nonumber :set ruler","tags":"Applications","title":"Vim常用技巧"},{"url":"http://wonux.github.io/apps-firefox-vimperator.html","text":"介绍 Vimperator是一个Firefox浏览器扩展，能够使Firefox浏览器像Vim一样高效工作。在安装上 Vimperator之后，无论是 Firefox 的外观，还是 Firefox 的行为，都像极Vim。Vimperator还具有类似键盘绑定的功能，这使你能够灵活地使用热键来完成各种操作。不过，如果你想使用好它，必须确认你要有使用vim的经验，如同vim一样，vimperator也有多种模式，它也是致力于抛弃鼠标，使手指不用离开键盘就能完成大部分工作，事实也证明这样做确实很高效，但前提是你要习惯这种工作方式。 HINT 模式 这个模式算是用于极度的命令行爱好者或者鼠标坏掉的用户，hint模式就是为当前页面所有的链接标上序号，然后只要敲击键盘选择对应的链接即可，你的手完全不需要离开键盘去摸鼠标——我个人很喜欢这种方式。 最基本的用法就是在页面按 f/F ，然后根据显示的数字来选择一下，链接就打开了。f会原页面打开，F则会在新页面打开。 当然，还可以用‘;{mode}{hint}'来实现更多复杂的操作，但是对我来讲前面的就已经足够了，细节可以参考帮助文档。 firefox系统功能 vimperator命令提供了firefox各种功能入口,常用的如下: 1 2 3 4 :dialog – To access some of Firefox's many dialog windows :bmarks – Vimperator provides a new interface to bookmarks :history – display a colorized, scrollable and clickable list of the locations in history. :emenu – Access the Firefox menus through the Vimperator command line. 打开网页 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 -- o :o :open :o[pen] [arg1], [arg2], … o O Show an :open prompt containing the current URL. :tabopen[!] [arg1], [arg2], … [!], 后台打开,不切换到新标签 -- t :t :tabopen :tabnew t T Show a :tabopen prompt containing the current URL. -- w :winopen :wopen :wino[pen][!] [arg1], [arg2], … w W p Open (put) a URL based on the current clipboard contents in the current buffer. P gP Works like P but inverts the 'activate' option. y Yank current location to the clipboard. 使用搜索引擎关键字搜索 :open baidu keywords 设置搜索引擎关键字: dialog searchengines . 历史导航 1 2 3 4 5 6 7 8 9 10 -- H <C-o> CTRL-O :ba :back :[count]ba[ck] [url] :ba[ck][!] [!] goes to the beginning of the browser history. -- L <C-i> CTRL-i :fo :fw :forward :[count]fo[rward] [url] :fo[rward]! ---------- :ju[mps] List all jumps aka current tab's history aka session history. gh Go home. Opens the homepage in the current tab. gH 标签页操作 我个人是非常喜欢使用 VIM 的Buffer操作的，简单快捷，精准。 而vimperator则是非常忠实的再现了这一特性，唯一不同的就是，这里的Buffer就相当于Tab。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 -- B :tabs :ls :files :buffers :buffers [filter] Show a list of buffers. %当前标签 #上一个标签 -- b :b :buffer [count]b Go to the specified buffer from the buffer list. [count]gb Repeat last :buffer! command. [count]gt Go to the next tab. [count]gT Go to the previous tab. [count]d Delete current buffer tab. :tabo[nly] Close all other tabs. -- u :u :undo [count]u Undo closing of a tab. -- :undoa :undoall :undoa[ll] Undo closing of all closed tabs. Firefox存储10个最近关闭的标签(包括重启firefox). d – close the active tab (delete the buffer) 刷新网页 1 2 3 r Force reloading of the current web page. R Force reloading of the current web page skipping the cache. :re[load][!] Reload current web page.If [!] is given, skip the cache. 退出 1 2 3 4 5 6 7 8 9 10 11 12 -- :q :quit :q[uit] Quit current tab. The session is not stored. -- :qa :qall :quita :quitall :quita[ll] Quit Vimperator. Quit Vimperator, no matter how many tabs/windows are open. The session is not stored. -- :wc :wclose :winc :winclose :winc[lose] Close window. -- :winon :winonly :winon[ly] Close all other windows. --:xa : xall :wq :wqa :wqall :xa[ll] Save the session and quit. ZQ Quit and don't save the session. Works like :qall. ZZ Quit and save the session.Works like :xall. Buffer Motion commands 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 -- <Home> gg [count]gg Go to the top. [count] scrolls to [count]%. -- <End> G [count]G Go to the end. [count] scrolls to [count]%. {count}% Scroll to {count} percent of the document. -- <Left> h [count]h Scroll to the left. [count], times to move to the left. -- <Right> l [count]l Scroll to the right. [count], times to move to the right. -- <C-e> <Down> j [count]j Scroll document down. [count], times to move to the down. -- <C-y> <Up> k [count]k Scroll document up. [count], times to move to the up. -- <C-d> Scroll window down to half a page in the buffer. -- <C-u> Scroll window up to half a page in the buffer. -- <S-Space> <PageUp> <C-b> [count]<C-b> Scroll up a full page. Scroll window [count] pages upwards. -- <Space> <PageDown> <C-f> [count]<C-f> Scroll down a full page. Scroll window [count] pages downwards. [count]gi Focus last used input field or first input field. Zooming 1 2 3 4 5 6 7 8 9 10 [count]zi Enlarge text zoom of current web page. Mnemonic: zoom in. [count]zI Enlarge full zoom of current web page. Mnemonic: zoom in. [count]zo Reduce text zoom of current web page. Mnemonic: zoom out. [count]zO Reduce full zoom of current web page. Mnemonic: zoom out. [count]zm Enlarge text zoom by a larger amount. Mnemonic: zoom more. [count]zM Enlarge full zoom by a larger amount. Mnemonic: zoom more. [count]zr Reduce text zoom by a larger amount. Mnemonic: zoom reduce. [count]zR Reduce full zoom by a larger amount. Mnemonic: zoom reduce. [count]zz Set text zoom value of current web page. [count] 30% to 300% default 100%. [count]zZ Set full zoom value of current web page. [count] 30% to 300% default 100%. Copying text 1 2 y Yank current location to the clipboard. Y Copy currently selected text to the system clipboard","tags":"Applications","title":"firefox神器：vimperator插件"},{"url":"http://wonux.github.io/apps-zathura.html","text":"介绍 Zathura是一款新的 PDF 查看器 ，它相当轻巧，界面简约（与 Apvlv 很相似），且可以定制（如按键绑定、默认窗口大小等 ）,支持vim风格快捷键。除了 PDF 查看器所具有的一般功能之外，Zathura 还包括搜索、表单编辑、可点击链接、导出图像等其他功能。 快捷键 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 gg G j/k/h/l J/K 翻一页 Tab 打开/关闭index（一般是目录） o 打开另外的文件 f Follow a link on the page m 标记位置（用过vim的都知道的。。） ' 跳转到标记位置 [0-9]+G 到指定页 a 放大页面到合适大小 s 放大页面到窗口宽度 F5 Toggle fullscreen mode &#94;n Toggle statusbar visibility &#94;m Toggle inputbar visibility &#94;q 退出 常用命令： 1 2 3 :bmark xxx 创建书签 :blist 打开bookmark :q 退出","tags":"Applications","title":"vi风格pdf阅读器推荐：Zathura"},{"url":"http://wonux.github.io/apps-vifm.html","text":"介绍 vifm是Linux下一个基于ncurses的控制台文件管理器，我很少使用文件管理器，要用一下，就拿出vifm来。图形界面的文件管理器我不喜欢用，控制台下有人叫做mc的，功能很强大，但快捷键实在用不习惯，还经常和Terminal下的快捷键冲突，找来找去也只找到vifm这个还勉强可用，快捷键模拟vi，符合我的习惯。 vifm最主要的特点是模拟vi的快捷键，例如要复制某个文件，按yy，然后到目的文件夹，按p。要移动文件，将yy换成dd就可以了。直接重命名，则按cw。另外，删除文件并不是直接删除，而是移到分区根目录的 .vifm-Trash/ 中，所以不小心删错了，还可以找回来。比较常用的命令有： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 j,k 上下移动 h,l 在父/子目录之间移动 gg 移动到文件列表首行 G 移动到文件列表末行 M 移动到窗口中间 H,L 移动到窗口首末文件 gh 返回上级目录 gl,Enter 进入目录或打开文件 [count]dd,d[count]d 删除文件(放入回收站) [count]DD,D[count]D 删除文件(不放回收站) [count]yy,[count]Y,y[count]y 复制文件 p 粘贴文件 u undo last change Space,Tab 在两个panel之间切换 / 查找文件 m[a-zA-Z0-9] 标记文件 '[a-zA-Z0-9] 移到标记所在文件 za 切换隐藏文件显隐 zo 显示隐藏文件 zm 不显示隐藏文件 :fil regex 隐藏匹配regex的文件 zO 显示被:fil命令过滤的文件 zM 隐藏被:fil命令过滤的文件 cp 更改文件属性权限 cw 文件/文件夹重命名 cW 文件/文件夹重命名,不包含扩展名 ga 计算文件夹大小 !prog 执行系统命令, %f可以用来当前选中文件名 配置vifm 配置文件 Vifm creates and populates a .vifm/ folder in your home directory containing the following: vifmrc - a well commented configuration file that can be edited to suit your working style. vifm-help.txt - the help text vifminfo - bookmarks and trash contents - it is not recommended to edit this file by hand Trash/ directory - self explanatory colors/ directory - color schemes Default - well commented default color scheme - can be copied to create user-created color schemes To get started, read the information avaliable in: 1 2 /usr/share/vifm/vifm.txt /usr/share/vifm/vifm-help.txt 用户自定命令 用户可以根据自己习惯配置自定义命令,如创建cp, mv命令用于将一个面板中选中的文件复制/移动到另一个面板中去。 1 2 command! cp cp -r %f %D command! mv mv -r %f %D 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \" :com[mand][!] command_name action \" The following macros can be used in a command \" %a is replaced with the user arguments. \" %c the current file under the cursor. \" %C the current file under the cursor in the other directory. \" %f the current selected file, or files. \" %F the current selected file, or files in the other directory. \" %b same as %f %F. \" %d the current directory name. \" %D the other window directory name. \" %m run the command in a menu window command! df df -h %m 2> /dev/null command! diff vim -d %f %F command! zip zip -r %f.zip %f command! run !! ./%f command! make !!make %a command! mkcd :mkdir %a | cd %a command! vgrep vim \"+grep %a\" command! reload :write | restart 其中%a是一个特殊值，表示输入的参数，类似的%f表示当前选中的文件, %F表示在另一个面板中选中的文件，%d表示当前目录，%D表示另一个面板的当前目录。 集成命令: mkcd move copy 文件默认打开方式 vifm可以定义文件默认打开方式，这些都在 ~/.vifm/vifmrc 中配置。使用 file[x]type 定义文件的默认打开方式： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \" Pdf filextype *.pdf zathura %c %i &, apvlv %c, xpdf %c fileviewer *.pdf pdftotext -nopgbrk %c - \" Image filextype *.bmp,*.jpg,*.jpeg,*.png,*.gif,*.xpm \\ {View in feh} \\ feh -FZ %d --start-at %d/%c 2>/dev/null \\ {View in sxiv} \\ sxiv, \\ {View in gpicview} \\ gpicview %c, \\ {View in shotwell} \\ shotwell, fileviewer *.bmp,*.jpg,*.jpeg,*.png,*.gif,*.xpm convert -identify %f -verbose /dev/null \" Office files \" filextype *.odt,*.doc,*.docx,*.xls,*.xlsx,*.odp,*.pptx libreoffice %f & fileviewer *.doc catdoc %c fileviewer *.docx, docx2txt.pl %f - filextype *.doc,*.docx wps %f & filextype *.xls,*.xlsx et %f & 参考: https://wiki.archlinux.org/index.php/Vifm","tags":"Applications","title":"vi风格控制台文件管理器 — vifm 配置使用"},{"url":"http://wonux.github.io/apps-rtorrent.html","text":"rtorrent介绍 rtorrent是Linux下的bt下载软件,由于支持 DHT 网络,可以很好的于迅雷和Bitcomet的用户进行资源共享,所以很适合国内网络环境,下载速度极快. 配置： 因安装过程不自动生成配置文件，要手动在用户根目录新建 ~/.rtorrent.rc 文件。 其内容大体如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #最小允许peer数 min_peers = 3 #最大允许peer数 max_peers = 500 #最大同时上传用户数 max_uploads = 10 #最大下载950k/s 光纤用户使用,adsl请酌情修改 download_rate = 950 #最大上传200k/s 光纤用户使用,adsl请酌情修改 upload_rate = 200 #下载目录 directory = ~/Downloads #下载历史目录（此目录中包括下载进度信息和DHT节点缓存） session = ~/Downloads/session #（配置自动监视,把bt种子扔进～/Downloads/torrents目录就自动下载） schedule = watch_directory,5,5,load_start=~/Downloads/torrents/*.torrent #（配置自动监视,把bt种子从～/Downloads/torrents目录拿走就自动停止下载） schedule = untied_directory,5,5,stop_untied= #硬盘空间低于100M就自动停止一切下载） schedule = low_diskspace,5,60,close_low_diskspace=100M #（在总上传量达到200M的情况下上传/下载率达到200%,或者在总上传量不足200M情况下上传/下载率达到2000%,则停止上传） # schedule = ratio,60,60,\"stop_on_ratio=200,200M,2000\" #bt监听端口 port_range = 9400-9500 #随机从上面范围内选择端口 port_random = yes ######开启DHT###### dht = on #DHT所用的UDP端口 dht_port = 9501 #种子交换功能 peer_exchange = yes #（上传缓存,每个种子10M,小内存用户请酌情修改） send_buffer_size = 10M #（下载缓存,每个种子20M,小内存用户请酌情修改） receive_buffer_size = 20M #(修改编码以避免中文乱码） encoding_list=UTF-8 使用： 启动：命令行输入rtorrent 即可 1 gentoo ~ # rtorrent rtorrent就会自动下载~/Downloads/torrents目录下面的所有bt种子. 添加和删除 torrents： 回退键 用 URL 或者文件路径添加，采用 tab 键查看目录内容并自动完成，支持通配符，例如: ~/torrent/* 回车键 和回退键一样，但是添加的 torrent 保持非激活( inactive )状态 (用 &#94;s 激活) &#94;o 对选择的 torrent 设置新的下载目录，仅仅对还没有被激活过的 torrent &#94;s 开始下载，先运行 hash ，除非已经做过 &#94;d 停止激活的下载，或者删除一个停止的下载 &#94;r 初始化 torrent 的 hash 检查 a/s/d 增加上传带宽 1/5/50 KB . z/x/c 降低上传带宽 1/5/50 KB . A/S/D 增加下载带宽 1/5/50 KB . Z/X/C 降低下载带宽 1/5/50 KB . 注意： &#94;s 和 &#94;q 在 shell 里面经常用来控制屏幕的暂停，这会和 rTorrent 发生冲突，用 stty -a 来检查是否已经被使用，删除的办法是： stty stop undef stty start undef before running rTorrent (or reattaching to screen) to leave them undefined. You could also replace undef with some other code — &#94;p, say. &#94;d also usually sends end-of-file but ncurses passes this through to rTorrent. stty eof undef if you are worried. To fix this, you may also toggle the flow control in screen with &#94;a &#94;f until screen displays \"-flow\" in the bottom left corner. 退出： CTRL+q Global Keys 主屏幕视图操作 &#94;q 关闭 rTorrent，再按一次，强行关闭 上下 选择 torrent 右键 切换到下载视图 左键 回到前一个屏幕 &#94;r 检查 hash +/- 修改优先度 l 查看日志，空格退出 1 显示所有下载 2 显示所有下载，按文件名排序 3 显示开始的下载 4 显示停止的下载 5 显示完成的下载 6 显示未完成的下载 7 显示正在 hash 的下载 8 显示正在做种的下载 下载视图 right Switch to selected view left Switch to view selection or back to main view 1/2 Adjust max uploads. 3/4 Adjust min peers. 5/6 Adjust max peers. p Display peer info o Display torrent info i Display file list u Display tracker list t/T Initiate tracker request. Use capital T to force the request, ignoring the \"min interval\" set by the tracker. Peer list View Keys left Switch to view selection right Show peer details * Snub peer (stop uploading to this peer) k Kick peer (disconnect from peer) File list View Keys left Switch to view selection right Show file details space Change the file priority; applies recursively when done on a directory * Change the priority of all files / Collapse directories. While collapsed, press right to expand the selected directory. Tracker list View Keys left Switch to view selection * Enable/disable tracker space Rotate trackers in a group","tags":"Applications","title":"Linux BT 下载软件 — Rtorrent 配置使用"},{"url":"http://wonux.github.io/gentoo-file-encode.html","text":"Linux与Windows系统语言编码区别 在Linux操作系统下，我们有时打开在windows下的txt文件，发现在windows下能正常显示的txt文件出现了中文乱码。 出现这种情况的原因为两种操作系统的中文字符编码方式（压缩方式）不同，在windows环境中中文字符编码一般为gbk，而在linux环境中为utf8，这就导致了在windows下能正常显示txt文件在linux环境下打开呈现了乱码状态。 系统编码设置 locale.gen 文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # /etc/locale.gen: list all of the locales you want to have on your system # # The format of each line: # <locale> <charmap> # # Where <locale> is a locale located in /usr/share/i18n/locales/ and # where <charmap> is a charmap located in /usr/share/i18n/charmaps/. # # All blank lines and lines starting with # are ignored. # # For the default list of supported combinations, see the file: # /usr/share/i18n/SUPPORTED # # Whenever glibc is emerged, the locales listed here will be automatically # rebuilt for you. After updating this file, you can simply run `locale-gen` # yourself instead of re-emerging glibc. en_US.UTF-8 UTF-8 zh_CN.UTF-8 UTF-8 查看系统语言编码种类 /usr/share/i18n/locales/ 目录下包含系统支持的编码语言种类 1 2 3 4 5 gentoo ~ # ls /usr/share/i18n/locales/ en_US en_GB en_HK zh_CN zh_TW zh_HK ja_JP de_DE ...... gentoo ~ # 查看字符编码压缩方式 /usr/share/i18n/charmaps/ 目录下包含系统支持的字符编码方式 1 2 3 4 5 6 7 8 9 10 11 ls /usr/share/i18n/charmaps/ ANSI_X3.110-1983.gz IBM1026.gz ISO-8859-16.gz ANSI_X3.4-1968.gz IBM1047.gz ISO_8859-1,GL.gz ARMSCII-8.gz IBM1124.gz ISO-8859-1.gz ASMO_449.gz IBM1129.gz ISO-8859-2.gz GB18030.gz ISIRI-3342.gz SAMI.gz GB_1988-80.gz ISO_10367-BOX.gz SAMI-WS2.gz GB2312.gz ISO_10646.gz SEN_850200_B.gz GBK.gz ISO_11548-1.gz SEN_850200_C. HP-ROMAN9.gz ISO_6937.gz UTF-8.gz ...... enca 查看文件编码方式 1 enca -L zh_CN file ###检查文件的编码 解决方案 iconv编码转换 使用 iconv 命令进行文件编码转换，如乱码文件名为hello.txt，那么在终端输入如下命令： 1 iconv -f gbk -t utf8 hello.txt > hello.utf8.txt #### enca编码转换 使用 enca 命令转换: 1 2 enca -L zh_CN -x UTF-8 hello.utf8.txt ###将文件编码转换为\"UTF-8\"编码 enca -L zh_CN -x gbk hello.txt ###将文件编码转换为\"gbk\"编码 enca 有一个好处,如果文件本来就是你要转换的那种编码，它不会报错，还是会print出结果来， 而\"iconv\"则会报错。","tags":"Gentoo","title":"Gentoo解决windows txt文件中文乱码问题 — 文件编码介绍"},{"url":"http://wonux.github.io/gentoo-dual-network.html","text":"引言：本文配置网络通过 OpenRC/netifrc 方法（net.*scritps）配置。 1 2 3 4 5 6 7 8 9 10 外网网卡：enp3s4 内网网卡：enp2s0 - 外网地址（通过路由器） IP： 192.168.1.10 掩码： 255.255.255.0 网关： 192.168.1.1 - 内网地址 IP： 172.14.255.27 掩码： 255.255.0.0 网关： 172.14.0.1 1、分别设置网卡 IP ，默认网关设置外网网关。 编辑 /etc/conf.d/net 文件 1 2 3 config_enp3s4=\"192.168.1.10/24\" routes_enp3s4=\"default via 192.168.1.1\" config_enp2s0=\"172.14.255.27/16\"","tags":"Gentoo","title":"Gentoo双网卡同时启用上内外网"},{"url":"http://wonux.github.io/gentoo-network-method.html","text":"OpenRC/netifrc Netifrc is a collection of modules created to configure and manage network interfaces via individual, per-interface scripts located in the /etc/init.d/ directory. Enable Gentoo's network stack ( net.* scripts ). 检测网卡名字 1 2 3 ifconfig -a or ls /sys/class/net 添加网卡 通过 net.lo 链接 1 2 3 ln -s /etc/init.d/net.lo /etc/init.d/net.ifname /etc/init.d/net.ifname start rc-update add net.ifname default 配置网络 IP 编辑 /etc/conf.d/net 文件 1 2 config_ifname=\"192.168.1.10/24\" #ip、掩码 routes_ifname=\"default via 192.168.1.1\" #网关 添加 DNS 编辑`/etc/resolv.conf文件 1 2 nameserver 202.99.166.4 nameserver 202.99.160.68 Newnet enable the new network stack (experimental) DHCPCD D ynamic H ost C onfiguration P rotocol C lient D aemon ( DHCPCD ) is a popular DHCP client for Gentoo Linux users. 使用dhcpcd自动获取 IP ，需要将net.*scripts标本停用，并设置 /etc/conf.d/net 中 config_ifname=\"dhcp\" 或留空。 dhcpcd-ui https://wiki.gentoo.org/wiki/Dhcpcd-ui#Usage - dhcpcd-gtk NetworkManager NetworkManager is a network management software for Ethernet, Wifi, DSL , dialup, VPN , WiMAX and mobile broadband network connections. It's a good idea to use dhclient from net-misc/dhcp instead of net-misc/dhcpcd . NetworkManager GUI GTK : gnome-extra/nm-applet KDE Frontend: kde-misc/plasma-nm kde-misc/networkmanagement 参考： Network management Network_management_using_DHCPCD/OpenRC_message Netifrc Network management using DHCPCD NetworkManager","tags":"Gentoo","title":"Gentoo网络管理方法总结"},{"url":"http://wonux.github.io/git-pelican-elegant.html","text":"简介 elegant是Mac风格的优秀主题，简单，专注文章本身。 A responsive, minimal, and stylish theme for Pelican： https://github.com/talha131/pelican-elegant 配置 elegant插件需要的依赖： 1 2 3 pip install beautifulsoup4 pip install webassets pip install cssmin 详细设置： http://oncrashreboot.com/elegant-best-pelican-theme-features 预览 我的博客效果： http://wonux.github.io 我的开源配置： https://github.com/wonux Thanks to： http://www.gocalf.com/blog/ http://oncrashreboot.com/elegant-best-pelican-theme-features","tags":"Git","title":"Pelican-Elegant Mac风格主题配置"},{"url":"http://wonux.github.io/apps-openbox-tranparent.html","text":"X窗口下的透明效果设置 使用 transset + devilspie + xcompmgr 设置透明效果。 X窗口下没有现成的工具，但可以借助于Xcompmgr和transset。 在运行Xcompmgr之后，就可以用transset来设置窗口透明度了。 transset 设置透明度 opacity 变量：0～1。0表示完全透明，1表示不透明。如果不指定opacity参数，默认值是0.75 1 transset --help 查看用法 options: -h, —help display this message -t, —toggle force toggle of opacity -c, —click select by clicking on window (default) -p, —point select the window currently under the cursor -a, —actual select the actual window -n, —name NAME select by name, NAME is matched as regular expression —no-regex don't use regular expression for matching name -i, —id select by window id —inc increase by the given opacity —dec decrease by given opacity -m, —min OPACITY minimum possible opacity (default = 0) -x, —max OPACITY maximum possible opacity (default = 1) -v, —verbose print some debug info -V, —version print version number xcompmgr 显示透明效果 1 xcompmgr 但是， transset 是一个命令行工具，如何与窗口系统结合起来，开机启动就显示透明效果呢。下面介绍两种使用方式。 结合 devilspie 的使用 devilspie支持自动绑定某类窗口，即窗口启动时会触发后台devilspie程序的相应行为。devilspie的配置文件在~/.devilspie/目录中，比如随便建立一个文件opacity.ds。内容为 1 2 3 4 5 6 7 8 9 10 ( if ( or ( contains ( window_class ) \"Gvim\" ) ( contains ( application_name ) \"sakura\" ) ( contains ( application_name ) \"tilda\" ) ) ( begin ( spawn_async (str \"transset -t -i \" (window_xid) )) ) ) 应该比较好理解，当启动Gvim， sakura 或 tilda 时设置其透明度为0.75。如执行 devilspie -a ，然后启动那个应用，它的属性就会在devilspie的输出中显示出来。 注意，xcompmgr和devilspie的启动不一定要放在.xinitrc中，只要在X启动之前执行即可，比如在openbox环境中，加入autostart.sh也是可以的。 openbox下的使用 修改~/.config/openbox/rc.xml中的 项下面的鼠标绑定内容。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 <context name= \"Titlebar\" > <!-- 使用transset-df设置窗口透明效果 --> <mousebind button= \"C-Middle\" action= \"Click\" > <action name= \"Execute\" > <execute> transset-df -p </execute> </action> </mousebind> <mousebind button= \"C-Up\" action= \"Click\" > <action name= \"Execute\" > <execute> transset-df -p --inc 0.2 </execute> </action> </mousebind> <mousebind button= \"C-Down\" action= \"Click\" > <action name= \"Execute\" > <execute> transset-df -p -m 0.2 --dec 0.2 </execute> </action> </mousebind> 这样，你就可以在窗口标题栏上按Ctrl+中键切换透明度了，Ctrl+向上滚动增加透明度，Ctrl+向下滚动减少透明度。","tags":"Applications","title":"openbox设置透明效果"},{"url":"http://wonux.github.io/git-pelican.html","text":"前言 一直以来都希望拥有属于自己的个人博客，随性发点信息，写点技术感想，记录自己的生活，重要的是不受广告的影响、不被河蟹、不会担心有一天被莫名其妙地消失。 之前看过一篇 文章 ：\"像黑客一样写博客\"，一下子就被这种简单的方式深深的吸引住了。你只需要一个称手的文本编辑器（Markdown编辑器），再配合终端的git命令就 OK 了，其余的都不用管了，交给第三方去。几条简单的命令就可以发布博客。 优点： - 直接使用Markdown写文章 - 全站静态化，根据Markdown生成文章的静态页面 - 直接在Terminal把文章push到Github上即可，有版本管理真好，然后加之Github Page的支持，虽然有一些些小问题，比如缓存，但瑕不掩瑜 - 整个写作过程和写代码的过程是一致的，符合码农的行为习惯，也就是所谓的\"像黑客一样写博客\" 本博客是在Gentoo Linux环境下搭建完成，托管到Github Pages。 效果见我的博客: http://wonux.github.io 知识储备 搭建博客的工具选用了Pelican，Pelican是一个用Python语言编写的静态网站生成器，支持使用restructuredText和Markdown写文章，配置灵活，扩展性强，有许多优秀的主题和插件可供使用。Pelican 的Github地址是： https://github.com/getpelican/pelican ;主页： http://blog.getpelican.com/ 搭建过程中涉及如下技术知识，不过你不必害怕，只是使用它们的开源框架而已，并不需要自己编码，点击可以了解它们是如何的强大，当然你也可以略过它们，后面遇到时再进行了解。 假如你不能打开它们，原因你懂的，请爬墙解决~ Github: https://github.com/ Github Ppages: http://pages.github.com/ git: http://git-scm.com/ python: http://www.python.org/ pip: https://pypi.python.org/pypi pelican: http://blog.getpelican.com/ markdown: http://daringfireball.net/projects/markdown/syntax 搭建Pelican环境 安装git,pip 1 2 emerge --ask dev-cvs/git emerge --ask dev-python/pip 使用virtualenv工具创建pelican虚拟环境 1 2 3 4 emerge --ask virtualenv ## or pip install virtualenv virtualenv ~/virtualenvs/pelican cd ~/virtualenvs/pelican source bin/activate 安装pelican 1 pip install pelican 安装markdown,typogrify 1 2 pip install Markdown pip install typogrify 搭建博客站点 1 2 3 mkdir blog //创建文件夹，名称可根据自己喜欢定 cd blog pelican-quickstart pelican-quickstart 执行命令后，会提示输入博客的配置项，除了少数几个必填以外，其它都可以选择默认，而且都可以在pelicanconf.py文件中进行更改，所以你可以随意选择。 命令成功执行后，会出现pelican的框架，如下所示 1 2 3 4 5 6 7 8 9 blog/ ├── content # 存放输入的markdown或RST源文件 │ └── (pages) # 存放手工创建的静态页面，可选 │ └── (posts) # 存放手工创建的文章，可选 ├── output # 存放最终生成的静态博客 ├── develop_server.sh # 测试服务器 ├── Makefile # 管理博客的Makefile ├── pelicanconf.py # 配置文件 └── publishconf.py # 发布文件，可删除 选择博客主题 回到 blog 目录下，按如下步骤下载pelican官方主题，从里面挑选出自己喜欢的主题吧，大多数主题预览界面你可以打开这个网页 主题预览 进行查看。不过如今pelican又新出了很多主题，所以你需看看 pelican主题开源库 。 克隆主题到本地 1 git clone https://github.com/getpelican/pelican-themes.git 使用主题 打开 pelicanconf.py 配置文件，更改或添加 THEME 为自己喜欢的主题，例如本博客所挑选的elegant，更多的配置含义请关注 官方文档 。 1 THEME = 'pelican-themes/pelican-elegant' 添加评论系统 开启个人博客的原因在于分享知识，分享就需要交流，评论模块当然少不了。大多数主题默认支持Disqus。在 Disqus 上申请帐号，按照流程Disqus会分配给你站点的Shortname，记牢Shortname，如果忘了请进入admin/settings中查看。然后同理，在 pelicanconf.py 添加 国内也可以选择 多说 和 友言 . 1 DISQUS_SITENAME = Shortname 书写文章 完成上述博客主体搭建后，使用markdownpad创建一个.md文件，保存于content文件夹中（或自己加入posts文件夹）。 Metadata syntax for Markdown posts should follow this pattern: 1 2 3 4 5 6 7 8 9 10 Title : My super title Date : 2010 - 12 - 03 10 : 20 Modified : 2010 - 12 - 05 19 : 30 Category : Python Tags : pelican , publishing Slug : my - super - post Authors : Alexis Metaireau , Conan Doyle Summary : Short version for index and feeds This is the content of my super blog post . 发布博客站点 Publish your site 有三种方法可以发布博客： - pelican命令 - make 详细用法查看 Makefile 文件 - fabric 生成博客站点 Site generation 1 pelican /path/to/your/content/ [-s path/to/your/settings.py] 或 1 make html 生成的站点放在 output/ 目录下。 预览生成的站点 For Python 2, run: 1 2 cd output python -m SimpleHTTPServer For Python 3, run: 1 2 cd output python -m http.server 或 1 make serve 浏览 http://localhost:8000/ 地址预览效果. 部署博客站点 Deployment 原理：将 output 目录下生成的站点部署到自己的github pages. 自动化操作 Fabric 1 2 3 4 5 pip install Fabric fab build fab regenerate fab serve fab publish Make 1 2 3 4 5 6 make html make regenerate make serve make devserver make stopserver ./develop_server.sh stop 备注：发布的简单流程： pelican content 生成页面至 output 目录，然后 git push 将 output 目录推送到github站点的 gh-pages 分支，即可自动渲生成染博客。 预览我的博客效果 http://wonux.github.io http://wonux.coding.me 参考资料： http://www.xycoding.com/articles/2013/11/21/blog-create/","tags":"Git","title":"Pelican + Github 搭建静态个人博客"},{"url":"http://wonux.github.io/freebsd-apps.html","text":"Packages and Ports 概述 FreeBSD 将许多系统工具捆绑作为基本系统的一部分。另外，FreeBSD 提供了两种补充的技术来安装第三方软件：FreeBSD Ports Collection，从源代码安装； packages，从预编译的二进制版本安装。这两种方法都可以用于从本地介质， 或从网上直接安装您喜欢的应用程序的最新版本。 UNIX ®系统典型的安装第三方软件的步骤包括： 1 2 3 4 5 1、下载这个软件，软件的发布可能是源代码格式，或是一个二进制包。 2、从默认的发行格式解压软件，通常是用compress, gzip,或bzip2压缩过tar包。 3、阅读相关文档，了解如何安装。 (通常文件名是INSTALL或README， 或在doc/ 目录下的一些文档) 4、如果软件是以源代码形式发布的，那就需要编译它。可能需要编辑一个 Makefile文件, 或运行 configure脚本。 5、测试和安装软件。 FreeBSD的package是包含了一个应用的所有命令、全部的配置文件和文档的预编译好的副本 。package可以使用pkg命令来操作。 FreeBSD的port是一个可以自动从源代码编译成应用程序的文件集合。这些文件包含了自动下载、解开、打补丁、编译、安装应用的所有必要的信息。 pots系统也可以用于生成被包管理命令维护的packages。 packages 和 ports 都可以自动处理依赖库。 这两种技术是很相似，packages 和 ports有各自的强项，根据需要选择哪种方法安装一个特定的软件。 Package优点 - 一个压缩的 package 通常要比一个压缩的包含源代码的应用程序小得多。 - package 不需要进行额外的编译时间。 对于大型应用程序如 Mozilla， KDE 或 GNOME 来说这显得尤为重要， 特别是在您的系统资源比较差的情况下。 - package不需要理解任何在FreeBSD上编译软件的详细过程。 Port优点： - package 在编译时通常使用比较保守的选项，这是为了保证它们能够运行在大多数的系统上。通过从 port 安装，可以细微调整编译选项来产生适合于处理器的代码。 - 一些软件包已经把与它们相关的能做和不能做的事情的选项都编译进去了。从 port 中安装时，不一定要接受默认的选项， 可以自己来设置。 - 一些软件的许可条件禁止采用二进制形式发行。 它们必须以源代码形式发布，终端用户编译。 - 一些人不信任二进制发行形式。 至少有了源代码， (理论上) 可以亲自阅读它，寻找潜在的问题。 - 如果要自己对软件打补丁，您就需要有源代码。 查找软件 FreeBSD中可用的应用程序正在不断地增长着。有很多方法可以查找需要安装的软件。 - FreeBSD站点上维护着一个最新的的可搜索当前所有可用应用程序的列表，在 http://www.FreeBSD.org/ports/ 。ports可以通过程序名称或软件分类来搜索。 - Dan Langille维护着网站 FreshPorts， http://www.FreshPorts.org/ 。 FreshPort提供综合搜索工具，追踪ports中应用的变化。注册用户可以创建自定义检视列表，当有任何程序被升级时，他们就会发 email 提醒您。 - 如果不确定想要的应用程序的名字，可以尝试在 SourceForge.net or GitHub.com 这些网站中查找，然后回到 FreeBSD site 主站查看应用是否被port进去了（ be ported）。 - 查找二进制包仓库（binary package repository） pkg search xxx pkg search -o xxx - Ports集（Ports Collection）安装后，有几种方法可以查询本地ports树。查找一个port属于哪个category： whereis lsof lsof: /usr/ports/sysutils/lsof echo /usr/ports/*/*lsof* /usr/ports/sysutils/lsof - 另外一个查找软件的方法是用Ports Collection内嵌的搜索机制。要使用这个搜索机制, 需要先cd到/usr/ports目录下面，然后运行 make search name=program-name ，program-name是要查找的软件名。例如： 1 2 3 4 5 6 7 8 9 # cd /usr/ports # make search name=lsof Port: lsof-4.88.d,8 Path: /usr/ports/sysutils/lsof Info: Lists information about open files (similar to fstat(1)) Maint: ler@lerctr.org Index: sysutils B-deps: R-deps: 注意：内嵌搜索机制使用索引信息文件. 如果显示消息：the INDEX is required, 执行 make fetchindex 下载最新的索引文件. 显示精简信息，使用quicksearch特性： 1 2 3 4 5 # cd /usr/ports # make quicksearch name=lsof Port: lsof-4.88.d,8 Path: /usr/ports/sysutils/lsof Info: Lists information about open files (similar to fstat(1)) 为了更深入的搜索，还可以用 make search key=string ， string就是想搜索的部分内容。 它将搜索port的名字、 注释， 描述和从属关系， 如果不知道您想搜索的程序名字， 可以利用它搜索一些关键主题来找到需要的。 当使用search或quicksearch时，搜索的关键字不区分大小写。 使用pkg进行二进制包管理 pkg是FreeBSD传统的包管理工具的下一代替代者。它提供了很多特性，使处理二进制包更快，更简单。 pkg不是替代像 ports-mgmt/portmaster 或 ports-mgmt/portupgrade 这样的port管理工具，这些工具既可以使用二进制方式又可以通过ports集方式安装第三方软件，而pkg只安装二进制包。 安装pkg 从FreeBSD 8.4之后的版本包括了一个用于下载安装pkg（包括使用手册）的引导程序。（bootstrap utility） - To bootstrap the system, run: 1 /usr/sbin/pkg pkg常用命令 查看已安装软件包信息 pkg info 安装和移除软件包 pkg install 和 pkg delete 更新已安装软件包 pkg version pkg upgrade 审核已安装软件包 pkg audit -F 自动移除孤立依赖 pkg autoremove 移除陈旧package包 pkg clean pkg默认在一个缓存目录（PKG_CACHEDIR）存储二进制包，当使用pkg upgrade更新包时，旧的版本不会自动移除。 使用Ports Collection Ports Collection ── 本质上是 /usr/ports 目录下的一堆 Makefile、 Patches（补丁）和描述文件，这些文件用于在FreeBSD系统中编译和安装应用。 安装Ports Collection Portsnap Method FreeBSD的base system包含Portsnap. 这是一个获得Ports Collection的快速易用的工具也是对大多数用户推荐的方法。 1、下载压缩的 Ports 套件快照到 /var/db/portsnap： 1 portsnap fetch 2、如果是首次运行 Portsnap，则需要将快照释放到 /usr/ports： 1 portsnap extract 3、更新 /usr/ports： 1 2 portsnap fetch portsnap update 当使用fetch选项时，extract、update选项可以连续运行： portsnap fetch update Subversion Method 如果需要更多的控制ports tree或者本地更改需要维护， Subversion可以用于获得Ports Collection。 1、在检测ports tree之前Subversion必须安装。如果ports tree已经存在： 1 2 cd /usr/ports/devel/subversion make install clean 如果ports tree不可用： 1 pkg install subversion 2、Check out a copy of the ports tree. 使用离你最近的Subversion mirror替换 svn0.us-east.FreeBSD.org 1 svn checkout https://svn0.us-east.FreeBSD.org/ports/head /usr/ports 3、As needed, update /usr/ports after the initial Subversion checkout: 1 svn update /usr/ports Port Skeleton port skeleton 是让一个程序在 FreeBSD 上简洁地编译并安装的所需文件的最小组合。 每个 port skeleton 包含： 1 2 3 4 5 6 Makefile : Makefile 包括好几个部分， 指出应用程序是如何编译以及将被安装在系统的哪些地方。 distinfo : 这个文件包括这些信息：这些文件用来对下载后的文件校验和进行检查 ，来确保在下载过程中文件没有被破坏。 files /: 这个目录包括在 FreeBSD 系统上编译和安装程序需要用到的补丁。这些补丁基本上都是些小文件，指出特定文件作了哪些修正。它们都是纯文本的的格式，基本上是这样的 \"删除第 10 行\" 或 \"将第 26 行改为这样 ... \"，补丁文件也被称作 \" diffs \"，他们由 diff 程序生成。 这个目录也包含了在编译 port 时要用到的其它文件。 pkg - descr : 这是一个提供更多细节，有软件的多行描述。 pkg - plist : 这是即将被安装的所有文件的列表。它告诉 ports 系统在卸载时需要删除哪些文件。 port里面包含着如何编译源代码的指令，但不包含真正的源代码。ports中这个程序源代码标示文件叫 \"distfile\",构建port的过程中会自动存储已经下载的源码到/usr/ports/distfiles. 安装Ports 使用Ports Collection编译安装port，需要连接网络和超级用户特权。如果没有网络，则需要将 distfile 手工放到 /usr/ports/distfiles 中。 - 首先进入要安装 port 的目录： cd /usr/ports/sysutils/lsof - make install - make clean 编译port的时候可以使用 make install clean 节省步骤。 移除已安装的Ports 已经安装的ports可以使用 pkg delete 命令卸载。 也可以在ports目录，使用 make deinstall 命令 升级Ports 列出可以更新版本的ports： 1 pkg version -l \"<\" Important: Before attempting an upgrade, read /usr/ports/ UPDATING from the top of the file to the date closest to the last time ports were upgraded or the system was installed. This file describes various issues and additional steps users may encounter and need to perform when updating a port, including such things as file format changes, changes in locations of configuration files, or any incompatibilities with previous versions. Make note of any instructions which match any of the ports that need upgrading and follow these instructions when performing the upgrade. 执行Ports升级，使用Portmaster或者Portupgrade. - Upgrading Ports Using Portmaster ports-mgmt/portmaster package（或称port），是推荐的升级已安装Ports的工具，它被设计为随FreeBSD系统使用而不需要依赖其他ports的工具。它用/var/db/pkg/中的信息决定哪些ports需要升级。 1 2 cd /usr/ports/ports-mgmt/portmaster make install clean Portmaster 把 ports 分成4类： 1 2 3 4 Root ports (不依赖其他的 ports，也不被依赖) Trunk ports (不依赖其他的 ports，但是被其他的 ports 依赖) Branch ports (依赖于其他的 ports，同时也被依赖) Leaf ports (依赖于其他的 ports，但不被依赖) 可以使用 -L 选项列出所有已安装的 ports 和查找存在更新的 ports： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 portmaster -L ===>>> Root ports (No dependencies, not depended on) ===>>> ispell-3.2.06_18 ===>>> screen-4.0.3 ===>>> New version available: screen-4.0.3_1 ===>>> tcpflow-0.21_1 ===>>> 7 root ports ... ===>>> Branch ports (Have dependencies, are depended on) ===>>> apache22-2.2.3 ===>>> New version available: apache22-2.2.8 ... ===>>> Leaf ports (Have dependencies, not depended on) ===>>> automake-1.9.6_2 ===>>> bash-3.1.17 ===>>> New version available: bash-3.2.33 ... ===>>> 32 leaf ports ===>>> 137 total installed ports ===>>> 83 have new versions available 可以使用这个简单的命令升级所有已安装的 ports： 1 portmaster -a 如果你在升级的过程中发现了错误，你可以使用 -f 选项升级/重新编译所有的 ports： 1 portmaster -af 同样你也可以使用 Portmaster 往系统里安装新的 ports，升级所有的依赖关系之后并安装新的 port： 1 portmaster shells/bash 注意: Portmaster 默认在删除一个现有的 port 前会做一个备份包。如果新的版本能够被成功安装， Portmaster 将删除备份。 使用 -b 后 Portmaster 便不会自动删除备份。加上 -i 选项之后 Portmaster 将进入互动模式， 在升级每个 port 以前提示你给予确认。 Upgrading Ports Using Portupgrade portupgrade 工具是设计来简化升级已安装的 port 的操作的。 它通过 ports-mgmt/portupgrade port 来提供。它安装一系列用于ports管理的应用。然而，它依赖于ruby。 1 2 cd /usr/ports/ports-mgmt/portupgrade make install clean 在每次升级之前，推荐使用 pkgdb -F 命令来扫描已安装的 port 的列表， 并修正其所报告的不一致。 运行portupgrade -a升级系统中所安装的所有过时的 ports。 如果您希望在每个升级操作时得到确认， 应指定 -i 参数。 1 portupgrade -ai 如果您只希望升级某个特定的应用程序， 而非全部可用的 port，应使用portupgrade pkgname。 指定 -R 参数非常重要，portupgrade将首先升级指定程序所需要的所有ports。 1 portupgrade -R firefox 要使用预编译的 package 而不是 ports 来进行安装， 需要指定 -P。 如果指定了这个选项， portupgrade 会搜索 PKG_PATH 中指定的本地目录， 如果没有找到， 则从远程站点下载。 如果本地没有找到， 而且远程站点也没有成功地下载预编译包， 则 portupgrade 将使用 ports。 要禁止使用 port， 可以指定 - PP 。 1 portupgrade -PP gnome2 Ports and Disk Space 在通过 ports 编译和安装软件之后，您应记得清理临时的 work 目录， 其方法是使用 make clean 命令。 - If Portmaster is used to install a port, it will automatically remove this directory unless -K is specified. - If Portupgrade is installed, this command will remove all work directories found within the local copy of the Ports Collection: portsclean -C 另外,许多过时的源码文件被收集在目录 /usr/ports/distfiles 中. 如果安装了Portupgrade, 下列命令将删除那些不被其他port引用的过时的distfiles。 1 portsclean -D 使用Portupgrade移除所有的不被系统其他port引用的distfiles: 1 portsclean -DD 如果安装了Portmaster,使用: 1 portmaster --clean-distfiles 除了这些命令之外, ports-mgmt/pkg_cutleaves package（or port）自动完成移除已安装但不再使用的ports的任务。","tags":"FreeBSD","title":"UNIX 基础 — 安装应用程序: Packages 和 Ports"},{"url":"http://wonux.github.io/freebsd-man.html","text":"联机手册 Manual Pages 最详细的使用说明文档莫过于 FreeBSD 里的联机手册了。 几乎每一个程序都会附上一份简短说明， 以介绍这个程序的的基本功能以及参数的用法。 我们能通过 man 命令来阅读这些说明。 联机手册根据主题，分成下列章节: 1 2 3 4 5 6 7 8 9 1、 用户命令。 2、 系统调用以及错误代码。 3、 C 库文件里的函数说明。 4、 设备驱动程序。 5、 文件格式。 6、 游戏以及其他娱乐。 7、 各种资讯。 8、 系统维护以及命令。 9、 内核开发情况。 man 命令使用 加章节数字 例如查看chmod用户命令 1 man 1 chmod 搜索功能 -k 选项加关键字,或使用 / 搜索 1 man -k mail GNU Info 文件 FreeBSD许多应用软件以及实用工具来自Free软件基金会( FSF )。 作为手册的扩充，这些程序提供了一种更具有活力的超文档说明info， 您可用info命令来阅读他们。","tags":"FreeBSD","title":"UNIX 基础 — Manual Pages"},{"url":"http://wonux.github.io/freebsd-shells.html","text":"Shells Shell提供了一个和操作系统交互的命令行接口。shell的主要功能就是从输入取得命令然后去执行。FreeBSD内含了一些shell，包括:Bourne shell（sh）、 extended C shell（tcsh）。 其他shell也可在FreeBSD的Ports得到，例如:zsh和bash。 Shell的特点： 文件名补全 使用环境变量 Common Environment Variables 1 2 3 4 5 6 7 8 9 10 11 12 Variable Description USER Current logged in user's name. PATH Colon-separated list of directories to search for binaries. DISPLAY Network name of the Xorg display to connect to, if available. SHELL The current shell. TERM The name of the user's type of terminal. Used to determine the capabilities of the terminal. TERMCAP Database entry of the terminal escape codes to perform various terminal functions. OSTYPE Type of operating system. MACHTYPE The system's CPU architecture. EDITOR The user's preferred text editor. PAGER The user's preferred utility for viewing text one page at a time. MANPATH Colon-separated list of directories to search for manual pages. 怎样设置环境变量：不同的shell有不同的方法。 - 在tcsh和csh这样的C-Style shell，使用 setenv 设置环境变量 - 在sh和bash这样的Bourne shell，使用, export 设置环境变量 例如：设置或改变 EDITOR 环境变量，将 EDITOR 设为/usr/local/bin/vim. 在csh或tcsh下 1 setenv EDITOR /usr/local/bin/vim 在sh或bash下 1 export EDITOR=\"/usr/local/bin/vim\" 命令行中在环境变量前加一个$字符，可以取得环境变量查看当前设置。 shell里有许多特别的字符代表着特别的内容，我们把叫做meta-characters。最常用的就是 * 字符，它可代表文件名的任何字符。为了防止shell去分析这些特别字符， 我们可在它之前加一个 \\ 字符去说明它只是普通字符。 改变Shell 改变Shell的最简单方法是使用 chsh 命令。 - 执行 chsh 将根据 EDITOR 环境变量进入到那个编辑器，假如没有设定，就会进入vi编辑器。 请改变\"Shell:\"这行对应值。 - 可使用chsh 的-s选项， 这样就能设置您的shell却又不用编辑器。假如想把shell改为bash: 1 chsh -s /usr/local/bin/bash 注意:新的shell必须在 /etc/shells 文件里列出。 如果从ports里安装一个shell，应该默认自动添加到这个文件了。如果没有添加，用下面的命令添加： echo \"/usr/local/bin/bash\" >> /etc/shells ，然后从新运行 chsh . Shell高级技巧 Advanced Shell Techniques 重定向： > < 管道： |","tags":"FreeBSD","title":"UNIX 基础—Shells"},{"url":"http://wonux.github.io/freebsd-process.html","text":"进程和守护进程 Processes and Daemons 进程（Processes） FreeBSD 是一个多任务操作系统。 这就意味着好像一次可以运行一个以上的程序。 每个占用一定时间运行的程序就叫 进程 (process)。 你运行的每一个命令会至少启动一个新进程，还有很多一直运行着的系统进程， 用以维持系统的正常运作。 每个进程用来标识的一个编号就叫 进程 ID （ PID ）。而且，就像文件那样，每个进程也有所属用户和所属组。 所属用户和所属组使用在这方面:确定这个进程可以打开那些文件和那些设备， 从而在初期使用文件的权限。 多数的进程都有一个父进程， 而进程是依靠父进程来启动的。 例如，假如您把命令输入到shell里那shell是一个进程，而您运行的各个命令同样是进程， 那么，shell就是您各个运行进程的父进程。 而这方面有一个例外的进程就叫 init 。 init 是系统启动时第一个启动的进程，所以他的 PID 始终是1， 而init在FreeBSD起动时由内核自动启动。 查看系统上运行的进程，有两个命令非常有用: ps 和 top 。 ps命令作用是以静态列表显示当前运行进程， 显示 PID ，占用内存，它们启动的命令行。而top命令则是显示所有运行进程，并在以秒计的短时内更新数据，目的是交互地查看计算机正在运行的任务。 ps最有用的一个选项就是auxww。a选项显示出所有运行进程的内容， 而不仅仅是您的进程。u选项显示出进程所归属的用户名字以及内存使用，x选项显示出后台进程。 而ww选项表示为 ps 把每个进程的整个命令行全部显示完， 而不是由于命令行过长就把它从屏幕上截去。 守护进程（Daemons） 一些程序在运行中不需要连续的用户输入，一有机会就从终端里分离到后台去。我们把那些程序叫 守护进程。 守护进程的程序命名有一个惯例，在最后加一个 \"d\"。 BIND 是伯克利互联网域名服务 (而实际执行的程序名称则是 named)， Apache web server的程序就叫 httpd， 在行式打印机上的打印守护进程就是 lpd。 杀死进程（ Killing Processes） 有时可能会需要与进程进行通讯。 而 信号 则是其中的一种通讯机制。 可以发送信号给进程来与它进行通信， 不同的信号都有自己的数字编号,其中一些有特殊的含义， 其它的则可以被应用程序自己进行解释。 有两个信号可以停止进程: SIGTERM 和 SIGKILL 。","tags":"FreeBSD","title":"UNIX 基础 — 进程和守护进程"},{"url":"http://wonux.github.io/freebsd-disk.html","text":"磁盘组织 FreeBSD 查找文件的最小单位是文件名。 而文件名区分大小写，不凭文件扩展名去识别这个文件是 程序、 文档， 或是其他格式的数据。 在文件系统里目录和文件的作用是存储数据。 每一个文件系统都有且只有一个顶级目录 根目录， 这个根目录则可以容纳其他目录。 Slice FreeBSD将硬盘分成slices（片段），对应Windows系统的\"分区\"，Slices 有其编号， 从1到4，最多四个。Slices再分成分区（partitions）。Slice 编号在设备名后面， 并有一个 s 前缀， 从 1 开始。 每个磁盘上只能有四个物理的 slices， 但您可以在物理 slice 中使用适当的类型来创建逻辑 slice。 这些扩展 slice 编号从 5 开始。 分区的术语 FreeBSD将硬盘分成最多四个slice（片段），FreeBSD的开机区必须在这些slice其中之一。每一个slice上又可以分成最多8个 partition（分区）,分别称为a,b,c,d,e,f,g,h，传统上a,b,c,d分区有特殊的意义，a表示root分区，b表示swap分 区，c表示整个slice，d表示整个硬盘。 分区的顺序 文件系统是和分区一一对应的。因为FreeBSD的 UNIX 传统，每一个分区使用一个从 a 到 h 的字母来表示。 1 2 3 4 a分区：通常指定为根文件系统。 b分区：通常指定为交换分区。 c分区：通常它和所在的 slice 大小相同。 c 分区上工作时必定会影响到事整个 slice (举个例子，坏块扫描器)。 您通常不愿意在这个partition建立文件系统。 d分区：d曾经有特殊的含义，不过这种意义在现时的系统上已不再适用，因此 d 可以和任何其它普通的分区一样使用了。 只有c内定位整个slice，其他都可自由使用，但一般还是遵循传统观念，即a:root，b:swap，efgh:其他使用。 磁盘设备的代码 一个磁盘名字是用磁盘类型代码和编号来标识的， 它不像slices，磁盘的编号是由0开始的。 1 2 3 4 5 SATA 和 IDE 磁盘 ada或ad SCSI磁盘和USB存储设备 da SATA and IDE CD-ROM光驱 cd或acd SCSI CD-ROM光驱 cd 软驱 fd 在安装FreeBSD时，您首先要配置好磁盘slices， 然后在FreeBSD使用的slice上建立partitions。 并在每个partition上建立一个文件系统(或交换分区)， 和指定文件系统的挂接位置。","tags":"FreeBSD","title":"UNIX 基础 — 磁盘组织"},{"url":"http://wonux.github.io/freebsd-permission.html","text":"权限 Permissions FreeBSD使用传统的 UNIX ®系统的基本权限。在 UNIX ®系统中，基本权限分配了三种访问类型：读、写、执行。权限可以用字母r、w、x表示；也可以用二进制数表示，按rwx的顺序，x值1，w值2，r值4。 1 2 3 4 5 6 7 8 0 --- 1 --x 2 -w- 3 -wx 4 r-- 5 r-x 6 rw- 7 rwx 使用命令ls的-l参数可以显示出文件的所属者、 所属组和其他人等属性。 权限的符号化表示 Symbolic Permissions 1 2 3 4 5 6 7 8 9 10 11 12 13 Option Letter Represents (who) u User (who) g Group owner (who) o Other (who) a All (\"world\") (action) + Adding permissions (action) - Removing permissions (action) = Explicitly set permissions (permissions) r Read (permissions) w Write (permissions) x Execute (permissions) t Sticky bit (permissions) s Set UID or GID FreeBSD文件标志 FreeBSD File Flags FreeBSD 还支持使用 \"文件标志\"。这些标志为文件提供了进一步的安全控制机制，但这些控制并不适用于目录。这些文件标志提供了针对文件的进一步控制， 帮助确保即使是 root 用户也无法删除或修改文件。 setuid、setgid和sticky 权限 除了前面已经讨论过的那些权限之外，还有三个管理员应该知道的权限配置。它们是setuid、setgid和 sticky。这些配置对于一些 UNIX ® 操作而言很重要， 因为它们能提供一些一般情况下不会授予普通用户的功能。","tags":"FreeBSD","title":"UNIX 基础 — 权限"},{"url":"http://wonux.github.io/freebsd-account.html","text":"账户类型 系统账户 系统账户运行服务。 系统用户是那些要使用诸如 DNS 、 邮件， web等服务的用户。 使用帐户的原因就是安全； 如果所有的用户都由超级用户来运行， 那它们就可以不受约束地做任何事情。 典型的系统帐户包括daemon、operator、bind(供 域名服务 使用)、news， 以及www。 nobody是普通的没有特权的系统用户。 然而， 大多数与用户联系很密切的服务是使用nobody的， 记的这点非常重要， 这样可能使用户变的非常有特权。 用户账户 用户帐户是让真实的用户访问系统的主要方式， 这些帐户把用户和环境隔离， 能阻止用户损坏系统和其他用户， 在不影响其他用户的情况之下定制自己的环境。 - 用户名（User name） 用户名在login: 提示符的后面键入。 用户名对于一台计算机来讲是唯一的。用户名通常需要8个或更少的小写字母。 - 口令（Password） 每个帐户都有一个口令与它对应。 口令可以是空的， 这样不需要口令就可以访问系统。 这通常不是一个好主意； 每个帐户都应该有口令。 - 用户 ID ( UID ) UID 是系统用来识别用户的数字，推荐使用65535之内的 UID ，防止有些软件发生兼容性的问题。FreeBSD在内部使用 UID 来识别用户。任何您指定一个用户名的命令FreeBSD 都会把它转换成 UID 。 这意味着您可以用不同的用户名使用多个帐户， 但它们的 UID 是一样的。 FreeBSD 会把这些帐户认定是同一个用户。 - 组 ID ( GID ) GID 是用来识别用户所在的组的数字，组是一种基于用户 GID 而不是它们的 UID 的用来控制用户访问资源的机制。 这可以减少一些配置文件的大小。 一个用户也可以属于多个组。推荐使用65535之内的 GID 。 - 登录类（Login class） 登录类是对组机制的扩展,当把系统分配给不同用户时,它提供了额外的灵活性. - 口令的定期更改（Password change time） 默认情况下，FreeBSD 并不强制用户去改变他们的口令。您可以以用户为单位强制要求一些或所有的用户定期改变他们的口令。 - 帐户的到期时间（Account expiry time） 默认情况下FreeBSD不会自动完成帐户过期操作。如果您正在创建帐户，您应该知道一个帐户的有效使用期限。例如，在学校里您会为每个学生建立一个帐户，您可以指定它们何时过期。帐户过期后，虽然帐户的目录和文件仍然存在，但帐户已经不能继续使用了。 - 用户的全名（User's full name） 用户名可以唯一地识别FreeBSD的帐户，但它不会反映用户的全名。这些信息可能与帐户是相关的。 - 主目录（Home directory） 主目录是用户登录后启动的第一个目录的完全路径。通常的规则是把所有用户的主目录都放在 /home/username 下，或者 /usr/home/username 下。 用户将把他们的个人文件放在自己的主目录下，他们可以在那里创建任何目录. - 用户 shell Shell提供了用户用来操作系统的默认环境。有很多不同的shell，有经验的用户会根据他们的经验来选择自己喜好的shell。 超级用户账户 超级用户帐户， 通常叫做 root，超级用户拥有无限制的权限管理系统。在收发邮件， 系统检查或编程这样的日常工作中， 尽量不要使用root权限。 普通的用户帐户不会由于出错而破坏系统， 所以要尽可能的使用普通帐户， 除非您需要额外的特权。 获取超级用户权限： - root用户登录，不推荐。 - su 命令成为超级用户。 使用su命令的用户，必须属于wheel组；如果运行su时指定了 - ，用户将继承root用户的环境变量。 运行完命令时，使用 exit 命令离开超级用户账户，回到原来的用户权限。 安装 security/sudo 软件包。 管理账户 FreeBSD提供很多不同的命令管理用户账户，最常用的命令概括如下： adduser 添加用户 rmuser 删除用户 chpass 修改用户数据库信息 passwd 修改用户口令 pw 强大灵活修改用户帐户的工具","tags":"FreeBSD","title":"UNIX 基础 — 用户和基本账户管理"},{"url":"http://wonux.github.io/freebsd-console.html","text":"虚拟控制台和终端 Virtual Consoles and Terminals: FreeBSD 虚拟控制台的默认配置为8个，但并不是硬性设置， 您可以很容易设置虚拟控制台的个数增多或减少。 虚拟控制台的的编号和设置在 /etc/ttys 文件里。 1 2 3 4 5 6 7 8 9 10 11 12 # name getty type status comments # ttyv0 \"/usr/libexec/getty Pc\" xterm on secure # Virtual terminals ttyv1 \"/usr/libexec/getty Pc\" xterm on secure ttyv2 \"/usr/libexec/getty Pc\" xterm on secure ttyv3 \"/usr/libexec/getty Pc\" xterm on secure ttyv4 \"/usr/libexec/getty Pc\" xterm on secure ttyv5 \"/usr/libexec/getty Pc\" xterm on secure ttyv6 \"/usr/libexec/getty Pc\" xterm on secure ttyv7 \"/usr/libexec/getty Pc\" xterm on secure ttyv8 \"/usr/X11R6/bin/xdm -nodaemon\" xterm off secure FreeBSD 默认系统控制台是system console（ttyv0）,8个虚拟控制台virtual consoles (ttyv1 ~ ttyv8),(ttyv8)用于进入桌面环境。 FreeBSD使用 Alt+F1 ~ Alt+F9键，切换多个虚拟控制台。从图形界面切换至其他虚拟控制台要使用Ctrl+Alt。 单用户模式 Single User Mode 单用户模式主要用于修复系统启动失败，或者重新设置root密码。在单用户模式中，网络和虚拟控制台不能使用，但是可以提供完整的root权限，而不需要root密码。 单用户模式的控制台也可以在 /etc/ttys 文件中的设置。 1 2 3 4 5 # name getty type status comments # # If console is marked \"insecure\", then init will ask for the root password # when going to single-user mode. console none unknown off secure 可编辑把 secure 改为 insecure。 这样， 当用单用户进入 FreeBSD 时， 它仍然要求提供 root 用户的密码。 改变控制台的显示模式 Changing Console Video Modes FreeBSD 控制台默认的显示模式可以被调整为 1024x768， 1280x1024， 或者任何你的显卡芯片和显示器所支持的其他尺寸。 要使用一个不同的显示模式，加载vesa模块： 1 kldload vesa 使用 vidcontrol 工具来检测硬件支持的显示模式。 1 vidcontrol -i mode 这个命令的输出是一份你的硬件所支持的显示模式列表。使用 vidcontrol 命令来改变显示模式： 1 vidcontrol MODE_279 如果对于新的显示模式满意，那么可以把它加入到 /etc/rc.conf 使机器在每次启动的时候都能生效. allscreens_flags=\"MODE_279\"","tags":"FreeBSD","title":"UNIX 基础 — 控制台和终端"},{"url":"http://wonux.github.io/gentoo-wpa-supplicant.html","text":"安装 安装 net-wireless/wpa_supplicant 包 1 emerge --ask wpa_supplicant 启动网络 为wpa_supplicant添加无线接口 在 wpa_supplicant.conf 文件中添加 1 ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=wheel 初始化wpa_supplicant环境 1 wpa_supplicant -d -Dnl80211 -iwlan0 -c /etc/wpa_supplicant/wpa_supplicant.conf 参数： 1 2 3 4 5 -B - Fork into background. -c filename - Path to configuration file. -d increase debugging verbosity -i interface - Interface to listen on. -D driver - Optionally specify the driver to be used. For a list of supported drivers see the output of wpa_supplicant -h . nl80211 is the current standard, but not all wireless chip's modules support it. wext is currently deprecated, but still widely supported. 查看wpa_supplicant进程 1 2 3 ps -aux | grep wpa root 1841 0.0 0.2 6168 2920 ? Ss 09:10 0:00 wpa_supplicant -B -c/etc/wpa_supplicant/wpa_supplicant.conf -iwlan0 root 2122 0.0 0.0 2780 728 pts/0 S+ 09:25 0:00 grep --colour=auto wpa 配置 Set for Gentoo net.* scrips，tell the network script to use wpa_supplicant. File/etc/conf.d/net 1 2 3 4 modules_wlan0 = \"wpa_supplicant\" # 因为wpa_supplicant还不能很好的自动侦测驱动，所以需要我们为其指定正在使用的驱动。 wpa_supplicant_wlan0 = \"-Dnl80211\" config_wlan0 = \"dhcp\" Set for dhcpcd,no special setup is needed.Do not add wpa_supplicant to any runlevel. It will be controlled by dhcpcd. 配置文件 /etc/wpa_supplicant/wpa_supplicant.conf 1 2 3 4 5 6 7 8 9 10 11 12 13 # Allow users in the 'wheel' group to control wpa_supplicant ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=wheel # Make this file writable for wpa_gui update_config=1 #自动扫描AP（也就是可以上的无线网络热点） ap_scan=1 # 简单的情形：WPA-PSk密码验证方式，PSK是ASCII密码短语，所有合法的加密方式都允许连接 network={ ssid=\"simple\" psk=\"very secret passphrase\" # 优先级越高，就能越早匹配到。 priority=5 } To allow unprivileged users to control the connection using wpa_gui / wpa_cli, make sure GROUP=wheel and update_config=1 . 也可以使用 wpa_passphrase 命令添加无线热点 1 wpa_passphrase [ ssid ] [ passphrase ] >> /etc/wpa_supplicant/wpa_supplicant.conf 上面这条命令可以自动生成一段配置，我们将它输出添加到 wpa_supplicant 的默认配置文件里面。 wpa_cli 运行wpa_cli时可能会出现如下的错误： Could not connect to wpa_supplicant - re-trying 这个错误可能是因为你的wpa_supplicant进程没有启动起来造成的。 1 2 3 4 5 6 7 8 9 10 11 wpa_cli > scan > scan_results > add_network 0 > set_network 0 ssid \"MYSSID\" > set_network 0 psk \"passphrase\" > enable_network 0 > save_config OK dhcpcd interface 设置、获取 IP 自动获取 1 dhcpcd wlan0 手动设置 1 ifconfig wlan0 192.168.1.11 broadcast 192.168.1.255 netmask 255.255.255.0 告知Gentoo RC 系统网卡名字 1 2 3 4 5 6 7 cd /etc/init.d ln -s net.lo net.wlan0 #start and stop it using the following commands: /etc/init.d/net.eth0 start /etc/init.d/net.eth0 stop #开机启动 rc-update add wlan0 default","tags":"Gentoo","title":"Gentoo无线网络配置 — wpa_supplicant"},{"url":"http://wonux.github.io/apps-chroot.html","text":"chroot简介 chroot，即 change root directory (更改 root 目录)。在 linux 系统中，系统默认的目录结构都是以 / ，即是以根 (root) 开始的。而在使用 chroot 之后，系统的目录结构将以指定的位置作为 / 位置。 chroot是在unix系统的一个操作，针对正在运作的软件进程和它的子进程，改变它外显的根目录。一个运行在这个环境下，经由chroot设置根目录的程序，它不能够对这个指定根目录之外的文件进行访问动作，不能读取，也不能更改它的内容。 由chroot创造出的那个根目录，叫做\"chroot监狱\"（chroot jail，或chroot prison）。 为何使用 chroot 在经过 chroot 之后，系统读取到的目录和文件将不在是旧系统根下的而是新根下(即被指定的新的位置)的目录结构和文件，因此它带来的好处大致有以下3个： 增加了系统的安全性，限制了用户的权力； 在经过 chroot 之后，在新根下将访问不到旧系统的根目录结构和文件，这样就增强了系统的安全性。这个一般是在登录 (login) 前使用 chroot，以此达到用户不能访问一些特定的文件。 建立一个与原系统隔离的系统目录结构，方便用户的开发； 使用 chroot 后，系统读取的是新根下的目录和文件，这是一个与原系统根下文件不相关的目录结构。在这个新的环境中，可以用来测试软件的静态编译以及一些与系统不相关的独立开发。 切换系统的根目录位置，引导 Linux 系统启动以及急救系统等。 chroot 的作用就是切换系统的根位置，而这个作用最为明显的是在系统初始引导磁盘的处理过程中使用，从初始 RAM 磁盘 (initrd) 切换系统的根位置并执行真正的 init。另外，当系统出现一些问题时，我们也可以使用 chroot 来切换到一个临时的系统。 chroot 的使用 下面以Gentoo、Arch为例，说明chroot过程： 确定chroot的目标目录： 如果LiveCD环境，挂载系统所在根分区 1 mount /dev/sdx /mnt/gentoo 挂载/proc 1 2 3 mount -t proc none /mnt/gentoo/proc/ 或 mount -t proc proc /mnt/gentoo/proc/ 挂载/sys,/dev/ 1 2 mount --rbind /sys /mnt/gentoo/sys/ mount --rbind /dev /mnt/gentoo/dev/ 可选： 1 2 mount --rbind /tmp /mnt/gentoo/tmp (gentoo) mount --rbind /run /mnt/arch/run (arch) 复制 DNS 信息： 1 cp /etc/resolv.conf etc/resolv.conf chroot 1 chroot /mnt/gentoo /bin/bash 更新环境变量： 1 2 env-update (gentoo) source /etc/profile Optionally, create a unique prompt to be able to differentiate your chroot environment: 1 export PS1=\"(chroot) $ PS1 \" 结束语 在 Linux 系统初始引导的过程中，通常都有使用 chroot。但是 chroot 的好处不仅于此，它还增加了系统的安全性等。","tags":"Applications","title":"Linux系统维护 — chroot"},{"url":"http://wonux.github.io/apps-fstab.html","text":"fstab文件介绍 fstab文件包含了你的电脑上的存储设备及其文件系统的信息。它是决定一个硬盘（分区）被怎样使用或者说整合到整个系统中的文件。具体来说：用fstab可以自动挂载各种文件系统格式的硬盘、分区、可移动设备和远程设备等。对于Windows与Linux双操作系统用户，用fstab挂载 FAT 格式和 NTFS 格式的分区，可以在Linux中共享windows系统下的资源。 这个文件的全路径是 /etc/fstab 。它只是一个文本文件，你能够用你喜欢的编辑器打开它，但是必须是root用户才能编辑它。同时fsck、mount、umount的等命令都利用该程序。 /etc/fstab 是启动时的配置文件，不过，实际 filesystem 的挂载是记录到 /etc/mtab 与 /proc/mounts 这两个文件当中的。每次我们在更动 filesystem 的挂载时，也会同时更动这两个文件喔！ 系统挂载的一些限制 根目录 / 是必须挂载的﹐而且一定要先于其它 mount point 被挂载进来。 其它 mount point 必须为已创建的目录﹐可任意指定﹐但一定要遵守必须的系统目录架构原则 所有 mount point 在同一时间之内﹐只能挂载一次。 所有 partition 在同一时间之内﹐只能挂载一次。 如若进行卸除﹐您必须先将工作目录移到 mount point(及其子目录) 之外。 文件各字段解释 示例： 1 2 3 4 5 6 7 8 # <fs> <mountpoint> <type> <opts> <dump/pass> # NOTE: If your BOOT partition is ReiserFS, add the notail option to opts. /dev/sda10 /boot ext4 noauto,noatime 1 2 /dev/sda6 / ext4 noatime 0 1 /dev/sda9 none swap sw 0 0 /dev/cdrom /mnt/cdrom auto noauto,ro 0 0 其实 /etc/fstab (filesystem table) 就是将我们利用 mount 命令进行挂载时， 将所有的选项与参数写入到这个文件中就是了。除此之外， /etc/fstab 还加入了 dump 这个备份用命令的支持！ 与启动时是否进行文件系统检验 fsck 等命令有关。 挂载设备 : 不是我们通常理解的文件系统，而是指设备（硬盘及其分区， DVD 光驱等）。它告知我们设备（分区）的名字，这是你在命令行中挂载（mount）、卸载（umount）设备时要用到的。 挂载点：告诉我们设备挂载到哪里。 文件系统类型：Linux支持许多文件系统。 要得到一个完整的支持名单查找mount man-page。典型 的名字包括这些：ext2, ext3, reiserfs, xfs, jfs,iso9660, vfat, ntfs, swap和auto, ‘auto' 不是一个文件系统，而是让mount命令自动判断文件类型，特别对于可移动设备，软盘， DVD 驱动器，这样做是很有必要的，因为可能每次挂载的文件类型不一致。 文件系统参数：这部分是最有用的设置！！！ 它能使你所挂载的设备在开机时自动加载、使中文显示不出现乱码、限制对挂载分区读写权限。它是与mount命令的用法相关的，要想得到一个完整的列表，参考mount manpage. 备份命令：dump utility用来决定是否做备份的. dump会检查entry并用数字来决定是否对这个文件系统进行备份。允许的数字是0和1。如果是0，dump就会忽略这个文件系统，如果是1，dump就会作一个备份。大部分的用户是没有安装dump的，所以对他们而言 这个entry应该写为0。 是否以fsck检验扇区：启动的过程中，系统默认会以fsck检验我们的 filesystem 是否完整 (clean)。 不过，某些 filesystem 是不需要检验的，例如内存置换空间 (swap) ，或者是特殊文件系统例如 /proc 与 /sys 等等。fsck会检查这个头目下的数字来决定检查文件系统的顺序，允许的数字是0, 1, 和2。0 是不要检验， 1 表示最早检验(一般只有根目录会配置为 1)， 2 也是要检验，不过1会比较早被检验啦！一般来说,根目录配置为1,其他的要检验的filesystem都配置为 2 就好了。 常用参数： noatime 关闭atime特性，提高性能，这是一个很老的特性，放心关闭，还能减少loadcycle defaults 使用默认设置。等于rw,suid,dev,exec,auto,nouser,async，具体含义看下面的解释。 自动与手动挂载: auto 在启动或在终端中输入mount -a时自动挂载 noauto 设备（分区）只能手动挂载 读写权限: ro 挂载为只读权限 rw 挂载为读写权限 可执行: exec 是一个默认设置项，它使在那个分区中的可执行的二进制文件能够执行 noexec 二进制文件不允许执行。千万不要在你的root分区中用这个选项！！！ I/O同步: sync 所有的I/O将以同步方式进行 async 所有的I/O将以非同步方式进行 户挂载权限: user 允许任何用户挂载设备。 Implies noexec,nosuid,nodev unless overridden. nouser 只允许root用户挂载。这是默认设置。 临时文件执行权限： suid Permit the operation of suid, and sgid bits. They are mostly used to allow users on a computer system to execute binary executables with temporarily elevated privileges in order to perform a specific task. nosuid Blocks the operation of suid, and sgid bits. 重启系统 重启系统，或在终端中输入 mount -a 就可以看到修改后的效果了。","tags":"Applications","title":"文件系统配置启动挂载：fstab文件详解"},{"url":"http://wonux.github.io/gentoo-locale.html","text":"locale是什么？ 一份Locale是一组信息的集合，大多数程序利用它来确定特定的国家和语言设置。这些locale以及它们包含的数据是系统库的一部分，可以在大多数系统中的/usr/share/locale目录下找到。locale的名称通常命名为ab_CD的形式，其中ab是两个（或三个）字母的语言代号（在 ISO -639中指定）， CD 是两个字母的国家代号（在 ISO -3166中指定）。一些变量常常附加在locale名称的后面，例如en_GB. UTF -8或de_DE@euro。 locale环境变量 Locale的设置保存在环境变量中。典型情况下设置在 /etc/env.d/02locale （系统全局设置）和 ~/.bashrc （特定用户设置）文件中。这些变量分别决定locale各方面的设置，下面的表格给出了具体说明。所有变量都会取一个前述ab_CD格式的locale名称作为值。 locale把按照所涉及到的文化传统的各个方面分成12个大类，这12个大类分别是： 1 2 3 4 5 6 7 8 9 10 11 12 语言符号及其分类(LC_CTYPE) 数字(LC_NUMERIC) 比较和排序习惯(LC_COLLATE) 时间显示格式(LC_TIME) 货币单位(LC_MONETARY) 信息主要是提示信息,错误信息, 状态信息, 标题, 标签, 按钮和菜单等(LC_MESSAGES) 姓名书写方式(LC_NAME) 地址书写方式(LC_ADDRESS) 电话号码书写方式(LC_TELEPHONE) 度量衡表达方式(LC_MEASUREMENT) 默认纸张尺寸大小(LC_PAPER) 对locale自身包含信息的概述(LC_IDENTIFICATION)。 其中，与中文输入关系最密切的就是 LC_CTYPE,LC_CTYPE 规定了系统内有效的字符以及这些字符的分类，诸如什么是大写字母，小写字母，大小写转换，标点符号、可打印字符和其他的字符属性等方面。而locale定义zh_CN中最最重要的一项就是定义了汉字(Class \"hanzi\")这一个大类，当然也是用Unicode描述的，这就让中文字符在Linux系统中成为合法的有效字符，而且不论它们是用什么字符集编码的。 在en_US的locale定义中，并没有定义汉字，所以汉字不是有效字符。所以如果要输入中文必须使用支持中文的locale，也就是zh_XX，如zh_CN，zh_TW，zh_HK等等。 另外非常重要的一点就是这些分类是彼此独立的，也就是说LC_CTYPE，LC_COLLATE和 LC_MESSAGES等等分类彼此之间是独立的，可以根据用户的需要设定成不同的值。这一点对很多用户是有利的，甚至是必须的。例如，我就需要一个能够输入中文的英文环境，所以我可以把LC_CTYPE设定成。 怎样设定locale呢？ 设定locale就是设定12大类的locale分类属性，即 12个 LC_* 。除了这12个变量可以设定以外，为了简便起见，还有两个变量： LC_ALL 和 LANG 。它们之间有一个优先级的关系： LC_ALL > LC_* > LANG 可以这么说，LC_ALL是最上级设定或者强制设定，而 LANG 是默认设定值。 1 2 3 4 1.如果你设定了LC_ALL＝zh_CN.UTF-8，那么不管LC_*和LANG设定成什么值，它们都会被强制服从LC_ALL的设定，成为 zh_CN.UTF-8。 2.假如你设定了LANG＝zh_CN.UTF-8，而其他的LC_*=en_US.UTF-8，并且没有设定LC_ALL的话，那么系统的locale设定以LC_*=en_US.UTF-8。 3.假如你设定了LANG＝zh_CN.UTF-8，而其他的LC_*，和LC_ALL均未设定的话，系统会将LC_*设定成默认值，也就是LANG的值 zh_CN.UTF-8 。 4.假如你设定了LANG＝zh_CN.UTF-8，而其他的LC_CTYPE=en_US.UTF-8，其他的LC_*，和LC_ALL均未设定的话，那么系统的locale设定将是：LC_CTYPE=en_US.UTF-8，其余的 LC_COLLATE，LC_MESSAGES等等均会采用默认值，也就是LANG的值，也就是LC_COLLATE＝LC_MESSAGES＝……＝ LC_PAPER＝LANG＝zh_CN.UTF-8。 所以，locale是这样设定的： 1 2 3 4 1.如果你需要一个纯中文的系统的话，设定LC_ALL= zh_CN.XXXX，或者LANG= zh_CN.XXXX都可以，当然你可以两个都设定，但正如上面所讲，LC_ALL的值将复盖所有其他的locale设定，不要作无用功。 2.如果你只想要一个可以输入中文的环境，而保持菜单、标题，系统信息等等为英文界面，那么只需要设定LC_CTYPE＝zh_CN.XXXX，LANG= en_US.XXXX就可以了。这样LC_CTYPE＝zh_CN.XXXX，而LC_COLLATE＝LC_MESSAGES＝……＝ LC_PAPER＝LANG＝en_US.XXXX。 3.假如你高兴的话，可以把12个LC_*一一设定成你需要的值，打造一个古灵精怪的系统：LC_CTYPE＝zh_CN.GBK/GBK(使用中文编码内码GBK字符集)；LC_NUMERIC=en_GB.ISO-8859-1(使用大不列颠的数字系统)LC_MEASUREMEN=de_DE.ISO-8859-15@euro(德国的度量衡使用ISO-8859-15字符集)罗马的地址书写方式，美国的纸张设定……。估计没人这么干吧。 4.假如你什么也不做的话，也就是LC_ALL，LANG和LC_*均不指定特定值的话，系统将采用POSIX作为lcoale， 警告: LC_ALL设置之后不可被覆写，因此强烈反对使用。除非作测试请不要使用它，并且决不要把它设置在启动文件中。","tags":"Gentoo","title":"Gentoo本地化中文设置—Locale系统介绍"},{"url":"http://wonux.github.io/gentoo-grub-theme.html","text":"设置Gentoo Grub启动主题 拷贝官方LiveDVD grub主题： 下载官方 DVD ，找到 /boot/grub/themes/GenGrub目录，并拷贝出来。 安装GenGrub主题： 将GenGrub主题拷贝到系统的 /boot/grub/themes目录，并编辑grub配置文件： 1 nano -w /etc/default/grub 将主题路径设置成/boot/grub/themes/GenGrub/theme.txt 更新grub配置文件（grub2）： 1 grub2-mkconfig -o /boot/grub/grub.cfg 系统自动检测存在的操作系统和主题。 OK ，重启系统","tags":"Gentoo","title":"Gentoo启动菜单设置：使用官方LiveDVD Grub主题"},{"url":"http://wonux.github.io/gentoo-preserved-libs.html","text":"问题描述 1 2 3 4 5 6 7 8 9 10 11 !!! existing preserved libs: >>> package: media-libs/libmng-2.0.2-r1 * - /usr/lib/libmng.so.1 * - /usr/lib/libmng.so.1.0.0 * used by /opt/kingsoft/wps-office/office6/qt/plugins/imageformats/libqmng.so (app-office/wps-office-9.1.0.4751_alpha15) >>> package: media-libs/lcms-1.19-r2 * - /usr/lib/liblcms.so.1 * - /usr/lib/liblcms.so.1.0.19 * used by /usr/lib/libmng.so.1 (preserved) * used by /usr/lib/libmng.so.1.0.0 (preserved) Use emerge @preserved-rebuild to rebuild packages using these libraries 解决方法 折腾过程： emerge @preserved-rebuild 不起作用。 重装wps-office，再@preserved-rebuild，不起作用。 重装media-libs/libmng、package: media-libs/lcms不起作用。 1 2 3 4 emerge media-libs/libmng emerge media-libs/lcms emerge --depclean revdep-rebuild 4.卸载wps-office（一直无法解决，想卸载暂时放弃使用），preserved libs提示消失： 1 2 3 emerge -C wps-office emerge --depclean emerge @preserved-rebuild 5.第二天安装wps-office，成功无preserved libs提示。 总结 先卸载引起preserved libs的软件包（记得—depclean） @preserved-rebuild 重新安装软件","tags":"Gentoo","title":"Gentoo !!! existing preserved libs问题"},{"url":"http://wonux.github.io/gentoo-ntfs.html","text":"内核需要开启的选项 1 2 File systems ---> <*> FUSE (Filesystem in Userspace) support 使用 NTFS -3G NTFS -3G是一个由Tuxera公司开发并维护的开源项目，目的是为Linux提供 NTFS 分区的的驱动程序。它可以安全且快速地读写 Windows 系统的 NTFS 分区，而不用担心数据丢失。 安装软件包： 1 emerge -pv sys-fs/ntfs3g 临时挂载 NTFS 分区 可以使用下面的命令以读写方式临时装载一个 NTFS 分区到装载点 1 mount -t ntfs-3g <NTFS Partition> <Mount Point> 系统启动时挂载 NTFS 分区 编辑 /etc/fstab 1 vi /etc/fstab 在文件最后增加如下格式的行 ntfs-3g defaults 0 0 保存文件后重启系统或简单的执行下面的命令，即可装载 NTFS 分区到指定的装载点 1 mount -a","tags":"Gentoo","title":"Gentoo挂载Windowntfs的 NTFS 分区"},{"url":"http://wonux.github.io/gentoo-network.html","text":"网卡识别配置 要开始配置你的网卡，你首先需要告诉Gentoo RC 系统你的网卡。 可以用ifconfig命令查看自己网卡名字： 1 ifconfig -a 网卡名字（如eth0）的识别是通过在/etc/init.d目录里建立一个指向net.lo的符号链接来实现。 1 2 cd /etc/init.d ln -s net.lo net.eth0 启动和停止网络脚本 1 2 3 /etc/init.d/net.eth0 start /etc/init.d/net.eth0 stop rc-update add net.eth0 default #设置开机启动eth0 网络配置 命令方式（临时配置，重启后失效）： 设置网络包括了三个步骤： 使用ifconfig配置ip地址： 1 ifconfig eth0 192.168.1.10 broadcast 192.168.1.255 netmask 255.255.255.0 up 使用route来设定路由的网关： 1 route add default gw 192.168.1.1 创建/etc/resolv.conf配置 DNS ： 1 nano -w /etc/resolv.conf nameserver $202.99.166.4 nameserver $202.99.160.68 配置文件方式： 编辑网络配置文件/etc/conf.d/net和/etc/resolv.conf。 编辑/etc/conf.d/net配置主机 IP 地址、子网掩码和网关: 1 nano -w /etc/conf.d/net 使用 CIDR 形式表示的静态 IP ： 1 2 config_eth0=\"192.168.1.7/24\" routes_eth0=\"default via 192.168.1.1\" 使用netmask形式表示的静态 IP 1 2 config_eth0=\"192.168.1.7 broadcast 192.168.1.255 netmask 255.255.255.0\" routes_eth0=\"default via 192.168.1.1\" 注意: 如果你没有指定， DHCP 是默认选项。 测试： 测试是否能ping的通网关： 1 ping 192.168.1.1 如果能ping通，ip设置没错误。 测试 DNS ： 编辑/etc/resolv.conf配置 DNS ： 1 nano /etc/resolv.conf 在其中加入以下两行内容： 1 2 nameserver 202.99.160.68 nameserver 202.99.166.4 测试 DNS 解析是否正常： 1 ping www.baidu.com 如果能ping通， DNS 设置无误。","tags":"Gentoo","title":"Gentoo网络配置"},{"url":"http://wonux.github.io/gentoo-use.html","text":"Gentoo/Funtoo USE 标记 USE 的简单理解如下：一个软件不只包含软件本身，还包括其组件，如，文档，插件， GUI 支持等。 USE 就是用来标记是否要安装软件的同时安装这些组件。 声明 USE 标记 所有 USE 标记都声明在 USE 变量里面。默认的 USE 设定，在make.defaults文件（你的profile的一部分）里声明。 全局 USE 标记 不要通过修改make.defaults文件里的 USE 变量来满足你的需要：在升级Portage的时候，这个文件将会被破坏（被覆盖）。 要改变这个默认设置，你需要在 USE 变量里添加或移去关键字。这是通过在 /etc/make.conf 里定义 USE 全局变量来实现的。 全局 USE 标记适用范围是整个系统，保存在 /etc/portage/make.conf 文件中。 比如，如果使用 GNOME 而不想使用 KDE ，就希望所有软件都要默认支持 GNOME ， KDE 的支持就不要装，那么写上 USE ＝\"gnome -kde\"。前面加 - 表示移除。 当前可用的全局 USE 标记列表可以在网上或者本机的/usr/portage/profiles/use.desc文件里找到。 局部 USE 标记 局部 USE 标记只被单个包用来做该包特有的决定，保存在 /etc/portage/package.use 中。 比如，某个软件需要安装帮助文档，加上doc。 当前可用的局部 USE 标记列表可以在网上或本机的/usr/portage/profiles/use.local.desc 文件里找到。 临时 USE 标记 仅仅把 USE 变量声明成一个 环境变量 设定临时 USE 。比如，在安装 xxx 的时候不要装 jj 就声明： USE ＝ \"-jj\" emerge xxx USE 标记优先级 USE 标记这么多地方可以定义，有的加有的减，听谁的，需要有优先级来判断。 USE 优先级顺序如下（由低到高）： make.defaults（这个文件不要去修改）里面的 USE 默认设定 < 用户在/etc/make.conf里面的 USE 设定 < 用户在/etc/portage/package.use里面的 USE 设定 < 作为环境变量的 USE 设定 USE 标记颜色 emerge命令显示时，不同 颜色 USE 标记的意义: 1 2 3 4 *红色* 代表这次emerge用到的USE标记 *黄色* 表示从上次更新后该标记被增加、删除或者Masked *蓝色* 前面带-表示这次emerge屏蔽掉的USE标记 *绿色* 的是你本次编译添加的新USE标记，或者去掉的USE标记。 包特有的 USE 标记 查看特定包可用 USE 标记 1 emerge -pv xxx 系统上应用新的 USE 标记 如果你已经修改了你的 USE 标记，而且你想用新 USE 标记更新你的系统，可以使用emerge 的 --newuse 。 1 emerge --update --deep --newuse world （重新构建你的系统） 参考： http://en.gentoo-wiki.com/wiki/Portage http://www.gentoo.org/doc/en/handbook/handbook-x86.xml?part=2&chap=1 http://www.gentoo.org/dyn/use-index.xml","tags":"Gentoo","title":"Gentoo/Funtoo USE 标记介绍"},{"url":"http://wonux.github.io/git-git-submodule.html","text":"Git子模块(submodule)简介 经常有这样的事情，当你在一个项目上工作时，你需要在其中使用另外一个项目。也许它是一个第三方开发的库或者是你独立开发和并在多个父项目中使用的。这个场景下一个常见的问题产生了：你想将两个项目单独处理但是又需要在其中一个中使用另外一个。 子模块允许你将一个 Git 仓库当作另外一个Git仓库的子目录。这允许你克隆另外一个仓库到你的项目中并且保持你的提交相对独立。 Git子模块用法 添加一个子模块 首先你要把外部的仓库克隆到你的子目录中。 假设你想把 elegant 项目加入到你的blog项目中，你通过 git submodule add 将外部项目加为子模块： 1 2 cd blog git submodule add https://github.com/wonux/pelican-elegant.git pelican-themes/elegant 现在你就在项目里的 pelican-themes/elegant 子目录下有了一个 elegant 项目。你可以进入那个子目录，进行变更，加入你自己的远程可写仓库来推送你的变更，从原始仓库拉取和归并等等。 .gitmodules 配置文件，保存了项目 URL 和你拉取到的本地子目录。 克隆一个带子模块的项目 克隆你刚才创建子模块的项目。你将得到了包含子项目的目录，但里面没有文件： elegant 目录存在了，但是是空的。 你必须运行两个命令： git submodule init 来初始化你的本地配置文件， git submodule update 来从那个项目拉取所有数据并检出你上层项目里所列的合适的提交。 1 2 3 cd blog git submodule init pelican-themes/elegant git submodule update 现在你的pacman子目录就处于你先前提交的确切状态了。 参考： Git-子模块","tags":"Git","title":"Git子模块引用外部项目"},{"url":"http://wonux.github.io/git-hexo.html","text":"Hexo简介 Github上托管博客是使用jekyll搭建的，官方的Github Pages同样推荐使用它。我之前体验了一下jekyll，没有达到我想要的效果。于是寻找替代方案，搜索同类博客程序，我认识了hexo，hexo出自台湾大学生tommy351之手,是由Node.js驱动的一款快速、简单且功能强大的博客框架。Node.js是一个可以快速构建网络服务及应用的平台 。该平台的构建是基于Chrome's JavaScript runtime，也就是说，实际上它是对Google V8引擎（应用于Google Chrome浏览器)进行了封装。V8引擎执行Javascript的速度非常快，性能非常好。Node对一些特殊用例进行了优化，提供了替代的 API ，使得V8在非浏览器环境下运行得更好。它和jekyll相比，更快，更轻量。 Hexo安装 安装git Linux 大多数Linux发行版已经默认安装了git,如果没有直接使用包管理工具安装. Windows: Git-Downloads 安装node.js Gentoo package: net-libs/nodejs Arch: nodejs Windows: node.js 安装hexo 1 npm install hexo -g 配置Hexo 初始化博客根目录 1 hexo init blog 安装依赖包 1 npm install 安装之后，项目目录下出现如下文件结构： 1 2 3 4 5 6 7 8 9 . ├── _config.yml 全局配置文件 ├── package.json ├── scaffolds ├── scripts ├── source 文章存放位置 | ├── _drafts 草稿 | └── _posts 文章 └── themes 插件和主题 plugins: 插件 添加插件的基本操作是： 1 2 npm install <plugin-name> --save npm update 然后修改blog根目录下的_config.yml，添加： 1 2 plugins: - plugin-name themes: 安装主题： 1 git clone <repository> themes/<theme-name> 无论是插件还是主题在安装后都需要在根目录下_config.yml中修改plugins和theme的值以启用他们。 本博客使用 pacman 主题，扁平化设计，响应速快，推荐使用。修改配置参考: http://yangjian.me/workspace/introducing-pacman-theme/ 写文章 使用Markdown语法编辑文章。使用hexo new命令生成文章或者直接在_posts目录下直接创建文件，打开后先编辑文章头部信息，如下所示是本文的头部信息，以—-结尾。 1 2 3 4 5 6 7 8 9 10 11 title: 使用Hexo搭建个人静态博客 #文章页面上的显示名称，可以任意修改，不会出现在URL中 layout: post date: 2014-11-10 10:07:43 #文章生成时间，一般不改，当然也可以任意修改 updated: 2014-11-12 13:24 comments: true categories: - Blog tags: - hexo - blog --- 文章摘要 在需要显示摘要的地方添加如下代码即可： 1 2 3 以上是摘要 <!--more--> 以下是余下全文 文章中插入图片 使用markdown写文章，插入图片的格式为 ![图片名称](链接地址) ，这里要说的是链接地址怎么写。对于hexo，使用本地路径：在/source目录下新建一个img文件夹，将图片放入该文件夹下，插入图片时链接即为/img/图片名称。 发布博客 这里的发布也是十分简单的，首先在github上创建名为yourname.github.io的repo，接着修改_config.yml中的deploy字段，最后执行hexo d(前提是你已经在github上添加了你本机的ssh key)， OK ，现在通过yourname.github.io已经可以访问你的博客了。 1 2 3 4 deploy : type : github repo : git @ github . com : yourname / yourname . github . io . git branch : master 如果是博客主页以github项目的方式创建，分支选择gh-pages。 或 多个平台同时发布 1 2 3 4 5 deploy : type : git repo : gitcafe : https :// gitcafe . com /yourname/ yourname . git , gh - pages github : https :// github . com /yourname/ yourname . github . io . git , master Hexo使用 init 初始化博客 1 hexo init [folder] 如果目录不存在，将设置初始化当前目录 new 创建新文章 1 hexo new [layout] <title> 默认layout是post generate 生成静态网页文件 1 hexo generate publish 发布草稿 1 hexo publish [layout] <filename> server 启动本地服务 1 hexo server 搭建本地server，进行文章预览调试。 浏览器输入http://localhost:4000 就可以看到效果。 deploy 发布博客 1 hexo deploy clean 清除缓存 1 hexo clean 清除缓存文件：Cleans the cache file (db.json) and generated files (public). list 显示博客结构 1 hexo list route 列出生成的所有博客文件路径 常用命令 Hexo现在支持更加简单的命令格式了，比如： 1 2 3 4 5 6 7 8 9 hexo n == hexo new hexo g == hexo generate hexo p == hexo publish hexo s == hexo server hexo d == hexo deploy 发布博客： hexo g -d 或 hexo d -g 参考： - hexo.io - hexo on github - 搭建一个免费的，无限流量的Blog——github Pages和Jekyll入门 - pacman主题介绍 - hexo你的博客","tags":"Git","title":"Hexo + Github 搭建静态个人博客"},{"url":"http://wonux.github.io/apps-mplayer.html","text":"MPlayer 是我在 Linux 系统中用到的相当好的媒体播放程序，它因支持播放广泛的音／视频文件格式而著称。本文所要探讨的，除却一般的使用方法之外，更包括一些鲜为人知的提示和诀窍。相信在阅读此文后，你的多媒体播放体验将会增色不少。 配置文件 配置文件是 /etc/mplayer/mplayer.conf 和 ~/.mplayer/config 常用配置: 1 2 3 4 #subcp=cp936 #font=/usr/share/fonts/wqy-zenhei/wqy-zenhei.ttc slang = \"chs,eng\" sub-fuzziness=1 使用方法 简单实例: 1 mplayer -sub subtitle.srt -subcp cp936 -font /usr/share/fonts/wqy-zenhei/wqy-zenhei.ttc movie.avi 播放文件 使用 MPlayer 播放媒体文件最简单的方式是： mplayer <somefile> MPlayer 会自动检测文件的类型并加以播放，如果是音频文件，则会在命令行中显示该播放文件的状态信息；而假如是视频文件的话，则会打开一个新的播放窗口。 选择播放进度 −ss <时间> 参数指定的时间位置.示例: 1 2 mplayer <somefile> −ss 56 ###搜索到56秒处 mplayer <somefile> −ss 01:10:00 ###搜索到1小时10分钟处 倒退与快进 在播放文件的时候，你可以通过以下三组快捷键来对播放进程进行倒退与快进操作： 左方向键和右方向键：分别执行倒退 10 秒和快进 10 秒操作 下方向键和上方向键：分别执行倒退 1 分钟和快进 1 分钟操作 下翻页键和上翻页键：分别执行倒退 10 分钟和快进 10 分钟操作 播放 DVD 虽然 MPlayer 不支持 DVD 菜单，但是却能够播放 DVD 。你可以这样播放 DVD ： mplayer dvd://<titlenumber> 你需要使用实际的数字来替换 ，如 1、2、3 等。 使用字幕 当播放电影文件时，你可以指定字幕文件(idx,sub字幕文件)： mplayer -sub <somesubtitlefile> <somefile> mplayer -sub-paths <somesubpaths> <somefile> 中文字幕乱码问题 使用ass文件字幕需要加 -ass 参数:−ass (仅适用于FreeType)打开 SSA / ASS 字幕提供。 通过此选项, libass 将用于 SSA / ASS 外部字幕和 Matroska 轨迹。 mplayer <somefile> -sub-paths <somesubpaths> -ass 一般网上下载的字幕文件都是cp936的编码格式。如果不是，可以用iconv转换。比如utf8的转换成cp936的，命令如下： iconv -f utf8 -t cp936 -o name_of_movie.cp936.srt name_of_movie.utf8.srt 让mplayer自动识别字幕文件并加载 最简单的就是修改字幕文件，使其与电影同名（不包括最后的扩展名）。 其实我们可以用下面的方法让mplayer更智能的。在配置文件 ~/.mplayer/config 中加入下面两行： 1 2 slang = \"chs,cht,eng\" sub-fuzziness=1 −sub-fuzziness <模式> 搜寻字幕时调整匹配模糊度: 0 精确匹配;1 装载所有包含电影名称的字幕;2 装载当前目录的所有字幕。 有用的快捷键 以下是 MPlayer 中一些有用的快捷键： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 f－当播放视频时，在全屏和窗口模式之间切换。你也可以在命令行中使用 -fs 选项，以便让 MPlayer 开始在全屏模式中播放。 o－在播放视频时切换 OSD（OnScreen Display）模式。 p 或 Space－暂停／继续播放。 q 或 Esc－退出 MPlayer。在 GUI 模式时，Esc 不会退出，仅停止播放。 / 和 * 或 9 和 0－减小或增大音量。 m－静音切换。 T（通常是 Shift + t）－播放窗口置顶切换。 b 和 j－在可用的字幕间循环。 x 和 z－调整字幕的延迟时间。 I（Shift + i）－显示播放电影的文件名称。 1 和 2－调整对比度。 3 和 4－调整亮度。 5 和 6－调整色度。 7 和 8－调整饱和度。","tags":"Applications","title":"Mplayer使用及快捷键"},{"url":"http://wonux.github.io/gentoo-xorg-failed.html","text":"错误描述： 安装完xorg-server后，startx启动桌面环境，出现缺少模块错误。 Xorg:Failed to load module \"……\" 查看log： 1 cat /var/log/Xorg.0.log | grep EE [75.403] ( EE ) Failed to load module \"modesetting\" (module does not exist, 0) [75.403] ( EE ) Failed to load module \"fbdev\" (module does not exist, 0) [75.403] ( EE ) Failed to load module \"vesa\" (module does not exist, 0) 解决方法： 查看xorg-drivers中INPUT_DEVICES和VIDEO_CARDS变量,在make.conf中添加缺失的标记。 1 emerge -pv xorg-drivers These are the packages that would be merged, in order: Calculating dependencies … done! [ebuild R ] x11-base/xorg-drivers-1.15 INPUT_DEVICES=\"evdev keyboard mouse -acecad -aiptek -elographics -fpit -hyperpen -joystick -mutouch -penmount -synaptics -tslib -vmmouse -void -wacom\" VIDEO_CARDS=\"intel -apm -ast -chips -cirrus -dummy -epson -fbdev -fglrx (-freedreno) -geode -glint -i128 -i740 -mach64 -mga -modesetting -neomagic -nouveau -nv -nvidia (-omap) (-omapfb) -qxl -r128 -radeon -radeonsi -rendition -s3virge -savage -siliconmotion -sisusb (-sunbw2) (-suncg14) (-suncg3) (-suncg6) (-sunffb) (-sunleo) (-suntcx) -tdfx -tga -trident -tseng -v4l -vesa -via -virtualbox -vmware (-voodoo)\" 0 kB 在VIDEO_CARDS中添加modesetting,fbdev,vesa即可。","tags":"Gentoo","title":"Gentoo Xorg:Failed to load module \"……\" 问题"},{"url":"http://wonux.github.io/apps-rfkill.html","text":"介绍 ​​​​​​​多​​​​​​​计​​​​​​​算​​​​​​​机​​​​​​​系​​​​​​​统​​​​​​​包​​​​​​​含​​​​​​​无​​​​​​​线​​​​​​​电​​​​​​​传​​​​​​​输​​​​​​​，其​​​​​​​中​​​​​​​包​​​​​​​括​​​​​​​ Wi-Fi、​​​​​​​蓝​​​​​​​牙​​​​​​​和​​​​​​​ 3G 设​​​​​​​备​​​​​​​。​​​​​​​这​​​​​​​些​​​​​​​设​​​​​​​备​​​​​​​消​​​​​​​耗​​​​​​​电​​​​​​​源​​​​​​​，在​​​​​​​不​​​​​​​使​​​​​​​用​​​​​​​这​​​​​​​些​​​​​​​设​​​​​​​备​​​​​​​时​​​​​​​是​​​​​​​一​​​​​​​种​​​​​​​浪​​​​​​​费​​​​​​​。​​​​​​​ RFKill 是​​​​​​​ Linux 内​​​​​​​核​​​​​​​中​​​​​​​的​​​​​​​一​​​​​​​个​​​​​​​子​​​​​​​系​​​​​​​统​​​​​​​，它​​​​​​​可​​​​​​​提​​​​​​​供​​​​​​​一​​​​​​​个​​​​​​​界​​​​​​​面​​​​​​​，在​​​​​​​此​​​​​​​界​​​​​​​面​​​​​​​中​​​​​​​可​​​​​​​查​​​​​​​询​​​​​​​、​​​​​​​激​​​​​​​活​​​​​​​并​​​​​​​取​​​​​​​消​​​​​​​激​​​​​​​活​​​​​​​计​​​​​​​算​​​​​​​机​​​​​​​系​​​​​​​统​​​​​​​中​​​​​​​的​​​​​​​无​​​​​​​线​​​​​​​电​​​​​​​传​​​​​​​输​​​​​​​。​​​​​​​当​​​​​​​取​​​​​​​消​​​​​​​激​​​​​​​活​​​​​​​传​​​​​​​输​​​​​​​时​​​​​​​，可​​​​​​​使​​​​​​​其​​​​​​​处​​​​​​​于​​​​​​​可​​​​​​​被​​​​​​​软​​​​​​​件​​​​​​​重​​​​​​​新​​​​​​​激​​​​​​​活​​​​​​​的​​​​​​​状​​​​​​​态​​​​​​​（软​​​​​​​锁​​​​​​​定​​​​​​​）或​​​​​​​者​​​​​​​将​​​​​​​其​​​​​​​放​​​​​​​在​​​​​​​软​​​​​​​件​​​​​​​无​​​​​​​法​​​​​​​重​​​​​​​新​​​​​​​激​​​​​​​活​​​​​​​的​​​​​​​位​​​​​​​置​​​​​​​（硬​​​​​​​锁​​​​​​​定​​​​​​​）。​​​​​​​ RFKill 核​​​​​​​为​​​​​​​子​​​​​​​系​​​​​​​统​​​​​​​提​​​​​​​供​​​​​​​应​​​​​​​用​​​​​​​程​​​​​​​序​​​​​​​编​​​​​​​程​​​​​​​界​​​​​​​面​​​​​​​（ API ）。​​​​​​​内​​​​​​​核​​​​​​​驱​​​​​​​动​​​​​​​程​​​​​​​序​​​​​​​被​​​​​​​设​​​​​​​计​​​​​​​为​​​​​​​支​​​​​​​持​​​​​​​ RFKill 使​​​​​​​用​​​​​​​这​​​​​​​个​​​​​​​ API 注​​​​​​​册​​​​​​​内​​​​​​​核​​​​​​​，并​​​​​​​包​​​​​​​含​​​​​​​启​​​​​​​用​​​​​​​和​​​​​​​禁​​​​​​​用​​​​​​​这​​​​​​​个​​​​​​​设​​​​​​​备​​​​​​​的​​​​​​​方​​​​​​​法​​​​​​​。​​​​​​​另​​​​​​​外​​​​​​​，RFKill 核​​​​​​​提​​​​​​​供​​​​​​​用​​​​​​​户​​​​​​​程​​​​​​​序​​​​​​​可​​​​​​​解​​​​​​​读​​​​​​​的​​​​​​​通​​​​​​​知​​​​​​​以​​​​​​​及​​​​​​​用​​​​​​​户​​​​​​​程​​​​​​​序​​​​​​​查​​​​​​​询​​​​​​​传​​​​​​​输​​​​​​​状​​​​​​​态​​​​​​​的​​​​​​​方​​​​​​​法​​​​​​​。​​​​​​​ RFKill 界​​​​​​​面​​​​​​​位​​​​​​​于​​​​​​​ /dev/rfkill，其​​​​​​​中​​​​​​​包​​​​​​​含​​​​​​​系​​​​​​​统​​​​​​​中​​​​​​​所​​​​​​​有​​​​​​​无​​​​​​​线​​​​​​​电​​​​​​​传​​​​​​​输​​​​​​​的​​​​​​​当​​​​​​​前​​​​​​​状​​​​​​​态​​​​​​​。​​​​​​​每​​​​​​​个​​​​​​​设​​​​​​​备​​​​​​​都​​​​​​​在​​​​​​​ sysfs 中​​​​​​​注​​​​​​​册​​​​​​​当​​​​​​​前​​​​​​​ RFKill 状​​​​​​​态​​​​​​​。​​​​​​​另​​​​​​​外​​​​​​​，在​​​​​​​启​​​​​​​用​​​​​​​了​​​​​​​ RFKill 的​​​​​​​设​​​​​​​备​​​​​​​中​​​​​​​每​​​​​​​当​​​​​​​状​​​​​​​态​​​​​​​更​​​​​​​改​​​​​​​时​​​​​​​，RFKill 会​​​​​​​发​​​​​​​出​​​​​​​ uevents。​​​​​​​ Rfkill 是​​​​​​​一​​​​​​​个​​​​​​​命​​​​​​​令​​​​​​​行​​​​​​​工​​​​​​​具​​​​​​​，您​​​​​​​可​​​​​​​使​​​​​​​用​​​​​​​它​​​​​​​查​​​​​​​询​​​​​​​和​​​​​​​更​​​​​​​改​​​​​​​系​​​​​​​统​​​​​​​中​​​​​​​启​​​​​​​用​​​​​​​了​​​​​​​ RFKill 的​​​​​​​设​​​​​​​备​​​​​​​。​​​​​​​要​​​​​​​获​​​​​​​得​​​​​​​这​​​​​​​个​​​​​​​工​​​​​​​具​​​​​​​，请​​​​​​​安​​​​​​​装​​​​​​​ rfkill 软​​​​​​​件​​​​​​​包​​​​​​​。​​​​​​​ 使用 获​​​​​​​得​​​​​​​设​​​​​​​备​​​​​​​列​​​​​​​表 使​​​​​​​用​​​​​​​命​​​​​​​令​​​​​​​ rfkill list 获​​​​​​​得​​​​​​​设​​​​​​​备​​​​​​​列​​​​​​​表​​​​​​​，每​​​​​​​个​​​​​​​都​​​​​​​包​​​​​​​含​​​​​​​与​​​​​​​之​​​​​​​关​​​​​​​联​​​​​​​的​​​​​​​索​​​​​​​引​​​​​​​号​​​​​​​，从​​​​​​​ 0 开​​​​​​​始​​​​​​​。 1 2 3 4 rfkill list 0: phy0: Wireless LAN Soft blocked: yes Hard blocked: yes 停用设备 ​​​​​​​​​​​​​​可​​​​​​​以​​​​​​​使​​​​​​​用​​​​​​​​​​​​​​​​​索​​​​​​​引​​​​​​​号​​​​​​​让​​​​​​​ rfkill 停​​​​​​​止​​​​​​​使​​​​​​​用​​​​​​​或​​​​​​​者​​​​​​​使​​​​​​​用​​​​​​​某​​​​​​​个​​​​​​​设​​​​​​​备​​​​​​​。例​​​​​​​如​​​​​​​，停​​​​​​​用​​​​​​​系​​​​​​​统​​​​​​​中​​​​​​​第​​​​​​​一​​​​​​​个​​​​​​​启​​​​​​​用​​​​​​​ RFKill 的​​​​​​​设​​​​​​​备​​​​​​​​​​​​​​： 1 rfkill block 0 ​​​​​​还​​​​​​​可​​​​​​​以​​​​​​​使​​​​​​​用​​​​​​​ rfkill 阻​​​​​​​断​​​​​​​某​​​​​​​一​​​​​​​类​​​​​​​设​​​​​​​备​​​​​​​​​​​​​​。​​​​​​​例​​​​​​​如，停​​​​​​​用​​​​​​​系​​​​​​​统​​​​​​​中​​​​​​​的​​​​​​​所​​​​​​​有​​​​​​​ Wi-Fi 设​​​​​​​备​​​​​​​：​​ 1 rfkill block wifi 或​​​​​​​者​​​​​​​停​​​​​​​止​​​​​​​使​​​​​​​用所​​​​​​​有​​​​​​​启​​​​​​​用​​​​​​​了​​​​​​​ RFKill 的​​​​​​​设​​​​​​​备​​​​​​​： 1 rfkill block all 重​​​​​​​新​​​​​​​使​​​​​​​用​​​​​​​设​​​​​​​备 要​​​​​​​重​​​​​​​新​​​​​​​使​​​​​​​用​​​​​​​设​​​​​​​备​​​​​​​，请​​​​​​​运​​​​​​​行​​​​​​​ rfkill unblock，而​​​​​​​不​​​​​​​是​​​​​​​ rfkill block。​​​​​​​ 1 2 rfkill unblock wifi rfkill all 要​​​​​​​获​​​​​​​得​​​​​​​ rfkill 可​​​​​​​停​​​​​​​用​​​​​​​的​​​​​​​完​​​​​​​整​​​​​​​设​​​​​​​备​​​​​​​类​​​​​​​别​​​​​​​列​​​​​​​表​​​​​​​，请​​​​​​​运​​​​​​​行​​​​​​​ rfkill help。​​​​​​​ 参考： https://access.redhat.com/documentation/zh- CN /Red_Hat_Enterprise_Linux/6/html/Power_Management_Guide/RFKill.html","tags":"Applications","title":"RFKill软开关蓝牙及无线功能 — 解决无线网络连接失败问题"},{"url":"http://wonux.github.io/arch-wireless.html","text":"wifi-menu脚本 + dhcpcd","tags":"Arch","title":"Arch无线网络网络管理"},{"url":"http://wonux.github.io/arch-pacman.html","text":"Pacman是Arch Linux 的包管理器。它将一个简单的二进制包格式和易用的构建系统结合了起来。不管软件包是来自官方的 Arch 库还是用户自己创建，Pacman 都能方便得管理。 更新系统 在 Archlinux 中，使用一条命令即可对整个系统进行更新： pacman -Syu 如果你已经使用 pacman -Sy 将本地的包数据库与远程的仓库进行了同步，也可以只执行： pacman -Su 安装包 1 2 3 4 5 6 ➔ pacman -S：例如，执行 pacman -S firefox 将安装 Firefox。你也可以同时安装多个包， 只需以空格分隔包名即可。 ➔ pacman -Sy：与上面命令不同的是，该命令将在同步包数据库后再执行安装。 ➔ pacman -Sv：在显示一些操作信息后执行安装。 ➔ pacman -U：安装本地包，其扩展名为 pkg.tar.gz。 ➔ pacman -U http://www.example.com/repo/example.pkg.tar.xz 安装一个远程包（不在 pacman 配置的源里面） 删除包 1 2 3 4 ➔ pacman -R ：该命令将只删除包，保留其全部已经安装的依赖关系 ➔ pacman -Rs ：在删除包的同时，删除其所有没有被其他已安装软件包使用的依赖关系 ➔ pacman -Rsc ：在删除包的同时，删除所有依赖这个软件包的程序 ➔ pacman -Rd：在删除包时不检查依赖。 搜索包 1 2 3 4 ➔ pacman -Ss 关键字：在仓库中搜索含关键字的包。 ➔ pacman -Qs 关键字： 搜索已安装的包。 ➔ pacman -Qi 包名：查看有关包的详尽信息。 ➔ pacman -Ql 包名：列出该包的文件。 其他用法 1 2 3 ➔ pacman -Sw 包名：只下载包，不安装。 ➔ pacman -Sc：清理未安装的包文件，包文件位于 /var/cache/pacman/pkg/ 目录。 ➔ pacman -Scc：清理所有的缓存文件。","tags":"Arch","title":"Arch软件管理 — Pacman常用命令"},{"url":"http://wonux.github.io/arch-alsa.html","text":"ALSA Utilities Install the alsa-utils package. This contains (among other utilities) the alsamixer and amixer utilities. 1 pacman -S alsa-utils Unmuting the channels ALSA by default has all channels muted, all of which will need to be unmuted manually. This can be done using amixer: 1 amixer sset Master unmute This can alternatively be done using alsamixer: 1 alsamixer Test your changes 1 speaker-test -c 2 User privileges Usually, local users have permission to play audio and change mixer levels. To allow remote users to use ALSA , you need to add those users to the audio group. 参考： https://wiki.archlinux.org/index.php/Advanced_Linux_Sound_Architecture","tags":"Arch","title":"Arch声卡配置"},{"url":"http://wonux.github.io/arch-fcitx.html","text":"安装fcitx,安装gtk、qt模块。 1 2 3 4 5 [root@Arctux ~]# pacman -S fcitx-im :: There are 4 members in group fcitx-im: :: Repository community 1) fcitx 2) fcitx-gtk2 3) fcitx-gtk3 4) fcitx-qt4 Enter a selection (default=all): 安装fcitx配置工具 1 [root@ARCH ~]# pacman -S fcitx-configtool .xinitrc 文件添加gtk、qt支持 1 2 3 export GTK_IM_MODULE=fcitx export QT_IM_MODULE=fcitx export XMODIFIERS=@im=fcitx","tags":"Arch","title":"Arch安装fcitx"},{"url":"http://wonux.github.io/arch-handbook.html","text":"选择安装方式 CD / USB Arch启动盘安装 使用Arch启动盘比较简单方便，没有额外设置，直接阅读下一步。 USB flash installation media 启动盘制作： USB flash installation media 从已经存在的Linux系统中安装（非Arch类） 从已经存在的非Arch系统环境中安装arch，本质上是搭建引导过程中可以运行 arch-install-scripts 脚本(包括 pacstrap 和 arch-chroot 命令) 的系统环境。 创建Arch chroot环境 1、推荐使用 bootstrap 镜像 1 2 3 4 ### Download the bootstrap image from a mirror： [root@GENTOO ~] curl -O http://mirrors.kernel.org/archlinux/iso/2015.10.01/archlinux-bootstrap-2015.10.01-x86_64.tar.gz ### Extract the tarball: [root@GENTOO ~] cd /tmp# tar xzf <path-to-bootstrap-image>/archlinux-bootstrap-2015.10.01-x86_64.tar.gz 2、编辑 /tmp/root.x86_64/etc/pacman.d/mirrorlist 本件，选择镜像源 3、进入chroot环境 1 /tmp/root.x86_64/bin/arch-chroot /tmp/root.x86_64/ 使用Arch chroot环境 1、初始化pacman keyring 1 2 # pacman-key --init # pacman-key --populate archlinux 2、编辑 /etc/pacman.d/mirrorlist 本件，选择镜像源 3、更新软件列表 1 # pacman -Syyu 4、安装系统 Arch Chroot环境已经具备，继续下面的步骤，选择安装需要的系统 base , base-devel , parted 等. 参考： https://wiki.archlinux.org/index.php/Install_from_existing_Linux 准备 准备磁盘分区 新建并格式化分区 至少准备一个足够大的/分区，如果磁盘容量足够，可以额外创建/home、/boot等。 创建挂载目录 1 2 3 mkdir /mnt mkdir /mnt/boot mkdir /mnt/home 挂载根分区和swap Mount the root partition on /mnt. After that, create directories for and mount any other partitions (/mnt/boot, /mnt/home, …) and activate your swap partition if you want them to be detected later by genfstab. 1 2 3 mount /dev/sdax /mnt mount /dev/sdax/boot mount /dev/sdax/home 准备连接 有线： 默认使用Dhcp，一般自动检测，无需设置 无线： 1 wifi-menu 编辑镜像列表 1 wget -O /etc/pacman.d/mirrorlist https://www.archlinux.org/mirrorlist/all/ 取消注释中国的镜像 安装系统 1 pacstrap /mnt base 配置系统 fstab文件 Generate an fstab file (use -U or -L to define by UUID or labels): 1 genfstab -p /mnt >> /mnt/etc/fstab chroot 1 arch-chroot /mnt Hostname: 1 echo computer_name > /etc/hostname Time zone: 1 ln -sf /usr/share/zoneinfo/zone/subzone /etc/localtime Locale: 1 2 nano -w /etc/locale.gen locale-gen Password: 1 passwd Initial RAM : 1 mkinitcpio -p linux Bootloader: 安装grub2: 1 2 pacman -S grub grub-install --target=i386-pc --recheck /dev/sda Dual-booting: 1 pacman -S os-prober 生成grub配置文件 1 grub-mkconfig -o /boot/grub/grub.cfg 重启 1 2 exit reboot","tags":"Arch","title":"ArchLinux安装详解"},{"url":"http://wonux.github.io/arch-mirrors.html","text":"Official mirrors The official Arch Linux mirror list is available from the pacman-mirrorlist package. To get an even more up-to-date list of mirrors, use the Pacman Mirror List Generator page on the main site. 手动下载镜像列表 有时因为系统镜像列表丢失或可读性不强，我们需要从官方网站下载按地区分类的镜像列表，很简单，执行如下命令： 1 wget -O /etc/pacman.d/mirrorlist https://www.archlinux.org/mirrorlist/all/","tags":"Arch","title":"Arch下载官方镜像列表Official mirrors"},{"url":"http://wonux.github.io/apps-pastebin.html","text":"软件作用 直接把管道里面的文字内容传到网站上面，然后反馈一个地址可以读取内容。 同类软件 wgetpaste dpaste pastebin pasteie 用法 介绍wgetpaste为例： 1 2 GENTOO ~ # cat /etc/portage/make.conf | wgetpaste Your paste can be seen here: https://bpaste.net/show/bf4077579512 常见问题 pastebin服务源无法访问 解决办法： 列出可用的pastebin服务 1 2 3 4 5 6 7 8 9 10 11 GENTOO ~ # wgetpaste -S Services supported: (case sensitive): Name: | Url: =============|================= *bpaste | https://bpaste.net/ ca | http://pastebin.ca/ codepad | http://codepad.org/ dpaste | http://dpaste.com/ gists | https://api.github.com/gists lugons | https://paste.lugons.org/ poundpython | http://paste.pound-python.org/ 默认使用bpate 切换可用的pastebin服务，如dpaste 1 cat /etc /portage/make.conf | wgetpaste -s dpaste","tags":"Applications","title":"直接粘贴代码到网络上:command-line pastebins"},{"url":"http://wonux.github.io/apps-mpd.html","text":"MPD 、 MPC 介绍： 为何选用 MPD + MPC ？ 在Linux下有很多不错的音乐播放器，强大的如amarok，简单的如bmp，而我更喜欢mpc（需要安装 MPD ），简洁是我选择它的理由。每次开机自动打开守护程序MusicPD（简称mpd），这如同一个潜在的点歌器，终端下用mpc就能选听自己喜欢的歌曲，不需要任何界面，也不必为音乐播放器单开一个桌面。 mpc和conky结合，可以做出开机音乐；mpc和remind结合用音乐来提醒某些事情。守护程序mpd就像一个功能强大的点歌器，你可以轻松地选择你喜爱的歌手、专辑，毫不逊于 GUI 的音乐播放器。 我们还可以用conky在桌面上显示mpd的情况，显示歌曲名，显示歌手名，显示播放进程等，设计我们自己的音乐播放器，够酷吧。 MPD MPD (Music Player Daemon) ：它跟常见的大多数播放器都很不同，是一个C／S结构的音乐播放器。 MPD 作为一个守护程序运行于后台, 通过各种各样的client软件来控制播放动作、播放列表等， 占用很少的资源，从一开始使用我便喜欢上了这种方式。 这是一个可以在后台播放音乐的东东，非常节省资源，而且和X无关，在终端下一样能播放。而且可以用过各种各样的 MPC 前端来进行控制。 MPD 的优点很多，配置简单但是功能丰富。比如，可以选择音频设备，选择mixer设备，选择 ID3 编码等等。最大的好处就是音乐播放和管理前台分离，这样既可以使用mpc这个最简单的 MPD 客户端控制播放，也可以用 GMPC 和QMPDClient这样的强大 MPD 客户端进行音乐管理。 MPC 一个命令行下的Mpd客户端。 安装 MPD 1 emerge mpd 配置 MPD mpd的系统级配置文件是 /etc/mpd.conf ;用户级配置文件是 ~/.config/mpd/mpd.conf 或 ~/.mpdconf . 编辑 mpd.conf ： MPD 设置有几个地方： 1、 MPD 的音乐目录和进程需要存放一些数据库等文件的目录； 2、 MPD 的执行用户； 3、 MPD 的输出和混音器选择； 4、 MPD 的 ID3 编码. 1 2 3 4 5 6 7 8 9 music_directory \"/var/lib/mpd/music\" playlist_directory \"/var/lib/mpd/playlists\" db_file \"/var/lib/mpd/database\" log_file \"/var/lib/mpd/log\" state_file \"/var/lib/mpd/state\" user \"mpd\" bind_to_address \"localhost\" bind_to_address \"/var/lib/mpd/socket\" input { plugin \"curl\" } mpd默认配置使用mpd用户，默认的 ~ 目录是 /var/lib/mpd/ .要添加mpd用户对 /var/lib/mpd/ 目录相应的权限。 使用 MPD 启动mpd守护进程 1 /etc/init.d/mpd start 开机启动 1 rc-update add mpd default MPD Clients mpc vimpc gmpc glurp ario MPC mpc的常用参数： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 mpc add 添加歌曲到播放列表 mpc listall|mpc add 可以把所有歌曲都添加到当前的播放列表 mpc listall 可以列出所有的歌曲 mpc playlist 查看当前播放列表 mpc 查看当前播放歌曲的信息 mpc play 播放 mpc pause 暂停 mpc stop 停止 mpc next 播放下一首 mpc prev 播放前一首 mpc repeat on 启用重复播放 mpc random on 启用随机播放 mpc play 18 播放列表中第18首 mpc search filename 可以按文件名查找 mpc search artist 可以按歌手查找 mpc search title 可以按歌曲名查找 音量调节： mpc volume +20 mpc volume -20 mpc的更多选项可以看mpc的帮助。 Conky 强大的Linux系统监控及桌面美化应用，在这里不详细介绍，自己Google，Wiki。","tags":"Applications","title":"MPD + MPC +Conky 听音乐"},{"url":"http://wonux.github.io/gentoo-gcc-invalid.html","text":"错误描述 Gentoo软件安装错误,提示： gcc-config: Active gcc profile is invalid 解决方法： 列出可用的profile 1 gcc-config -l gcc-config: Active gcc profile is invalid! [1] i686-pc-linux-gnu-4.6.3 显示当前使用的profile 1 gcc-config -c gcc-config: Active gcc profile is invalid! [1] i686-pc-linux-gnu-4.6.3 设置profile 1 gcc-config i686-pc-linux-gnu-4.6.3 Switching native-compiler to i686-pc-linux-gnu-4.6.3 … Regenerating /etc/ld.so.cache… [ ok ]","tags":"Gentoo","title":"gcc-config:Active gcc profile is invalid 解决办法"},{"url":"http://wonux.github.io/gentoo-localization.html","text":"时区 你需要选择时区让系统知道你的地理位置，以保持正确的时间。在/usr/share/zoneinfo中查找你的时区。然后在/etc/conf.d/clock中设置时区。请忽略/usr/share/zoneinfo/Etc/ GMT *时区，因为它们的名字并不表示所指的地区。比如， GMT -8实际上是 GMT +8。 设置时区信息： 1 2 3 ls /usr/share/zoneinfo echo \"Asia/Shanghai\" > /etc/timezone emerge --config sys-libs/timezone-data 注意: 你可以做一个用户级的设置，在shell的rc文件（如bash的.bash_profile）中将 TZ 变量的值设为/usr/share/zoneinfo下的任何东西。本案例中 TZ =\"Asia/Shanghai\"。 硬件时钟 Gentoo Linux安装过程中，大多数情况下硬件时钟都是被设成 UTC （或 GMT ，格林威治标准时间），而时区则定为实际的本地时间。如果出于某种原因，你需要将硬件时钟设为非 UTC ，那么你就要编辑/etc/conf.d/hwclock，将 CLOCK 的值由 UTC 改为local。 1 2 3 CLOCK=\"UTC\" 或 CLOCK=\"local\" 安装中文字体 推荐开源文泉驿自由字体 1 2 emerge wqy-zenhei （文泉驿正黑） emerge wqy-microhei （文泉驿微米黑） 生成指定的Locale 可能你在系统中只要用到一个或者两个locale。你可以在/etc/locale.gen中指定所需的的locale。 中文有很多种编码，最流行的就是 UTF8 和 GBK 。我们推荐客户使用 UTF8 编码，因为这是国际标准，能兼容任何语言的编码。 添加locale到 /etc/locale.gen 1 nano -w /etc/locale.gen en_US ISO -8859-1 en_US. UTF -8 UTF -8 zh_CB. UTF -8 UTF -8 下一步是执行 locale-gen 。它会生成/etc/locale.gen文件中指定的所有locale。 1 locale-gen 你可以通过执行locale -a来检验所选的locale是否可用。 1 locale -a 设置一个Locale显示中文 在 /etc/env.d/02locale 中设置全局默认的系统locale LANG =\"zh_CN. UTF -8\" LC_COLLATE=\"C\" 在~/.bashrc中设置用户级的系统locale export LANG =\"zh_CN. UTF -8\" export LC_COLLATE=\"C\" 更新系统全局默认的locale： 设置好正确的locale后，一定要更新环境变量使系统知道所做的更改： 1 env-update && source /etc/profile 更新特定用户的locale： 1 source ~/.bashrc 更新环境后，你需要按下Ctrl-Alt-Backspace杀死X服务器，登出，然后以用户身份登入。 现在，检验一下所做的更改是否已经生效了： 1 locale 注： 另一种系统配置方式是保留默认的C locale，同时要能够表现 UTF -8字符。 这种选择可以通过使用下述设置来实现：LC_CTYPE=zh_CN. UTF -8","tags":"Gentoo","title":"Gentoo本地化设置—时区、时钟、字体、中文环境"},{"url":"http://wonux.github.io/gentoo-udev-netware.html","text":"问题描述： 配置网络时，很多新手运行ifconfig命令查看网卡时，会发现我们熟悉的eth0网卡没有了，或是发现一些不规则命名的东东，不错，那就是你的网卡。 因为内核升级（忘记具体哪个版本了）从udev-197将自动分配更好的接口,网卡的命名改变了。 参考资料： http://www.freedesktop.org/wiki/Software/systemd/PredictableNetworkInterfaceNames 从开机信息中可以看到提示： 1 dmesg |grep network [ 74.261872] systemd-udevd[14259]: renamed network interface wlan0 to wlp2s0 [ 74.391865] systemd-udevd[14259]: renamed network interface eth0 to enp0s4 解决方法： 使用老的命名方式（eth×）： 使用原来的网卡名字eth0,重置udev的rules： 方法一： 在kernel命令行选项里使用net.ifnames=0 ; 方法二：新建空文件文件/etc/udev/rules.d/80-net-name-slot.rules或注释掉里面内容 1 2 3 ln -s /dev/null /etc/udev/rules.d/80-net-name-slot.rules 或 touch /etc/udev/rules.d/80-net-name-slot.rules 使用新的网卡名字： 1 2 3 4 5 6 rm /etc/udev/rules.d/80-net-name-slot.rules rm /etc/init.d/net.eth0 #删除不存在的引用 rc-update delete net.eth0 default #删除不存在的开机启动 cd /etc/init.d ln -s net.lo net.enp0s3 rc-update add net.enp0s3 default #使用新名字","tags":"Gentoo","title":"Gentoo解决Udev升级的网卡重命名问题"},{"url":"http://wonux.github.io/arch-xorg-lxde.html","text":"安装最小化的 LXDE 桌面环境： 1 pacman -S lxde-common 安装 LXDE Session： 1 pacman -S lxsession 不安装这个没法登录进桌面环境 安装 LXDE 面板： 1 pacman -S lxpanel 不安装这个，进入 LXDE 桌面环境后什么都没有 安装窗口管理器: 1 pacman -S openbox 不安装这个，既不能移动窗口，也不能最大、最小化窗口 安装 LXDE 环境下的终端程序: 1 pacman -S lxterminal 安装 LXDE 环境下的文件管理器: 1 pacman -S pcmanfm 总结 根据自己需要取舍上述组件，现在我仅仅使用 openbox ， DIY 配合其他工具，超精简流畅。","tags":"Arch","title":"ArchLinux最小化安装 LXDE 桌面环境"},{"url":"http://wonux.github.io/arch-xorg.html","text":"Xorg xorg-server 安装xorg-server 1 pacman -S xorg-server 可选：xorg-server-utils 1 pacman -S xorg-server-utils Xorg-server-utils meta-package pulls in the most useful packages for certain configuration tasks, they are pointed out in the relevant sections. Driver installation 如果不知道显卡类型，请执行如下命令进行查询： 1 lspci | grep VGA 输入下面命令，查看所有开源驱动: 1 pacman -Ss xf86-video | less 安装显卡驱动: vesa： 1 pacman -S xf86-video-vesa vesa是一个支持大部分显卡的通用驱动，不提供任何 2D 和 3D 加速功能。 要充分发挥显卡性能，请按下表安装驱动程序。推荐先使用开源驱动，这些驱动出问题的可能性较小。 AMD / ATI : 1 pacman -S xf86-video-ati Intel: 1 pacman -S xf86-video-intel Nvidia: 1 pacman -S xf86-video-nouveau Running Display manager: 最简单的方法是使用登录管理器 例如 GDM , KDM or SLiM. Manually： 如果不用登陆管理器启动 X，需要安装软件包 xorg-xinit。 1 2 pacman -S xorg-xinit pacman -S xorg-twm xorg-xclock xterm startx 和 xinit 命令将启动 X 服务器和客户端(startx 脚本是更通用命令 xinit 的前端)。为了确定要运行的客户端，startx/xinit 先在用户目录解析 ~/.xinitrc 文件，如果 ~/.xinitrc 不存在，使用默认的 /etc/X11/xinit/xinitrc, 其中默认会使用 Twm 窗口管理器，Xclock 和 Xterm（需安装 xorg-twm, xorg-xclock 和 xterm）. To launch the X server and clients: 1 startx","tags":"Arch","title":"Arch最小化安装X"},{"url":"http://wonux.github.io/gentoo-handbook-clock.html","text":"升级后的gentoo不再使用/etc/conf.d/clock，而是使用/etc/conf.d/hwclock来设置和时间相关了。 在/etc/conf.d/hwclock文件中设置系统时间为本地时间而不是 UTC 时间: 1 clock=\"local\" #default: UTC 然后用date命令设置正确的系统时间，格式如下： 1 date [MMDDhhmm[YY][.ss］ 其他的不用解释了，其中的 YY 表示年份的前２位数。 然后再把系统时间同步到硬件时间就可以了： 1 hwclock --systohc 使用hwclock命令也可以把硬件时间同步到系统时间： 1 hwclock --hctosys 显示硬件时间则是： 1 hwclock --show","tags":"Gentoo","title":"Gentoo解决Windows双系统时间不同步的问题"},{"url":"http://wonux.github.io/apps-scrot.html","text":"简介： scrot 主要用在命令行下，它使用 imlib2 库来抓取并保存图像。scrot 的使用格式为：scrot [options] [file]。 一般用法： 就一般而言，使用 scrot 可以抓取整个桌面、某个指定的窗口、以及选择的矩形区域。 抓取桌面：scrot desktop.png，该命令将当前的整个桌面抓取下来，并保存为 desktop.png 文件。可以在当前的目录中找到此图像文件。 抓取窗口：scrot -bs window.png，选项 b 使 scrot 在抓取窗口时一同将外边框抓取下来，而 s 选项则让用户选择所要抓取的是何窗口。 抓取区域：scrot -s rectangle.png，在执行此命令后，使用鼠标拖曳的矩形区域将被 scrot 抓取下来。 高级使用 对于普通的抓取使用 scrot 的基础便足以应付了。但在某些特殊情况之下，使用 scrot 抓取图像需要讲究一些技巧。 延时抓取：scrot -cd 10 menu.png，此命令中的 d 选项用于延时抓取图像，其后的 10 代表延时 10 秒；前面的选项 c 显示倒计时。在抓取菜单或是命令提示时，该技巧将充分展示其魔力。 生成缩图：scrot -t 50% thumb.png，这个命令在抓取图像的同时生成该图像的缩略图。选项 t 将打开此功能，其后的 50% 为原图的缩放百分比。 更改品质：scrot -q 70 quality.jpg，此命令中的 q 选项用于更改所抓图像的品质，其数值介于 1-100 之间，默认为 75。数值越大，意味着图像品质越高；同时，图像的压缩率也就越低，占用空间越大。 操作抓图：scrot action.png -e ‘mv $f ~/images/'，该命令将抓取的图像移动到 ~/images/ 目录。显然，操作图像的功能由 e 选项开启，其中的 $f 代表原图的路径／文件名。 以上示例皆指定了需要保存的抓图的文件名称。实际上，如果不指定名称，那么 scrot 在抓取图像后会自动使用当前的日期时间、宽度高度的组合来生成文件名称。","tags":"Applications","title":"Linux下截图工具：scrot 从入门到精通"},{"url":"http://wonux.github.io/gentoo-handbook-alsa.html","text":"硬件检测 To choose the right driver, first detect the used audio controller. You can use lspci for this task: 1 lspci | grep -i audio 内核配置 You need to activate the following kernel options: 1 2 3 4 5 6 7 8 9 10 11 12 13 Device Drivers ---> Sound ---> <*> Sound card Support <*> Advanced Linux Sound Architecture ---> [*] PCI sound devices ---> Select the driver for your audio controller, e.g.: <*> Intel HD Audio ---> (snd-hda-intel) Select a codec or enable all and let the generic parse choose the right one: [*] Build Realtek HD-audio codec support [*] ... [*] Build Silicon Labs 3054 HD-modem codec support [*] Enable generic HD-audio codec parser 软件 You also want to install media-sound/alsa-utils, if it isn't already pulled in: 1 emerge --ask alsa-utils 配置 权限 Add the user you want to be able to access the sound card to the audio group: 1 gpasswd -a larry audio 服务 You can now start ALSA : 1 /etc/init.d/alsasound start To start ALSA at boot time, add it your boot runlevel: 1 rc-update add alsasound boot Mixer调节音量，取消静音 If you can't hear anything, the output channels may be muted. Unmute the channels with your desktop environment's mixer or with alsamixer by selecting the appropriate channels and hitting the m key to mute or unmute: 1 alsamixer 测试声音 If everything above is perfect, you should now be able to test your sound card and your speakers. We will use the speaker-test command line tool from package media-sound/alsa-utils (this should already be installed as per our previous recommendation). 1 speaker-test -t wav -c 2","tags":"Gentoo","title":"Gentoo安装详解（五）—声卡设置"},{"url":"http://wonux.github.io/gentoo-handbook-xorg.html","text":"安装X桌面环境： 安装Xorg： 检测显卡信息： 1 2 dmesg | grep video lspci | grep -i VGA 配置INPUT_DEVICE、VIDEO_CARDS变量： 在安装Xorg之前，你需要在/etc/portage/make.conf文件中设置两个重要的变量。 1 2 3 4 5 6 7 8 9 10 (For mouse, keyboard, and Synaptics touchpad support) INPUT_DEVICE=\"evdev synaptics\" （对nVidia显卡） VIDEO_CARDS=\"nvidia\" （或，对ATI Radeon显卡） VIDEO_CARDS=\"radeon\" （VMware虚拟机） VIDEO_CARDS=\"vmware\" （VirtualBox虚拟机） VIDEO_CARDS=\"virtualbox\" 安装xorg-server\" 1 emerge -pv xorg-drivers First of all, make sure udev is in your USE flags: 1 echo \"x11-base/xorg-server udev\" >> /etc/portage/package.use Next, install Xorg: 1 emerge -av xorg-server 注：现在比较新的版本的Xorg（大概是 1.5 以后的吧） 使用 evdev 替换了 keyboard 和 mouse ，确保 udev 标记在安装 xorg-server 时被启用。 更新环境变量： 1 2 env-update source /etc/profile 使用startx： 安装 twm 和 xterm 之后 执行 startx 测试 X 是否正常。 测试正常之后可以删除 twm 和 xterm。 1 2 emerge -v twm xterm startx 安装桌面环境： 这里选择轻量快速的 awesome 和 openbox （严格上不算完整的桌面环境，称为wm窗口管理器）配置介绍。它们自定义性比较强，可以根据自己喜好配置成各种效果。为了兼顾部署速度，我大多数选择默认配置，只做微量调整。 awesome 安装awesome： awesome3.5.5以上版本,支持使用dmenu类似[Mod4+P]的命令补全。 1 emerge --ask awesome 配置awesome： 配置文件位于 ~/.config/awesome/rc.lua 主题文件在 /usr/share/awesome/theme/default/theme.lua 1 2 mkdir -p ~/.config/awesome/ cp /etc/xdg/awesome/rc.lua ~/.config/awesome/rc.lua 检测： 更改配置文件后可以用下面的命令检测是否正确。 1 2 awesome -k ✔ Configuration file syntax OK 使用startx启动： 编辑 ~/.xinitrc 文件 1 exec ck-launch-session dbus-launch --sh-syntax --exit-with-session awesome 常用配置 1 2 3 4 5 6 7 8 9 10 11 -- {{{ Variable definitions -- Themes define colours, icons, font and wallpapers. beautiful.init(\"/usr/share/awesome/themes/default/theme.lua\") -- This is used later as the default terminal and editor to run. terminal = \"tilda\" editor = os.getenv(\"EDITOR\") or \"nano\" editor_cmd = terminal .. \" -e \" .. editor -- Autostart awful.util.spawn_with_shell(\"fcitx &\") -- awful.util.spawn_with_shell(\"feh --bg-scale /usr/share/wallpaper/gentoo-gold.jpg\") -- }}} 音量控制： 后台启动 volumeicon & 1 emerge --ask volumeicon 设置壁纸： feh设置壁纸 feh --bg-tile /path/to/image.jpg —bg-scale —bg-center —bg-fill —bg-max 1 emerge --ask feh 除了在rc.lua中添加自启动应用命令，还可以添加 /etc/xdg/awesome/autostart 脚本。 在awesome中，terminal推荐tilda、sakura。 openbox 安装openbox： 1 emerge --ask x11-wm/openbox 配置openbox： 配置文件位于 /etc/xdg/openbox 1 2 mkdir -p ~/.config/openbox/ cp /etc/xdg/openbox/* ~/.config/openbox/ 使用startx启动： 编辑 ~/.xinitrc 文件 1 exec ck-launch-session dbus-launch --sh-syntax --exit-with-session openbox-session Autostart脚本： 1 vim ~/.config/openbox/autostart 右键菜单配置： 1、安装Gentoo特有包 x11-misc/openbox-menu ，自动生成menu，不依赖 etc/xdg/menus 文件夹下的信息。 1 2 emerge --ask x11-misc/openbox-menu openbox-menu 2、使用MenuMaker更新menu。 1 2 emerge menumaker mmaker -v OpenBox3 1 cp .config/openbox/menu.xml /etc/xdg/openbox/menu.xml 或使用-f参数覆盖 配置主题： GUI 工具obconf 1 2 emerge obconf obconf openbox去边框 Openbox 在匹配窗口的 name、class 及 role 时，可以使用通配符 * 和 ?。其中，* 用来匹配任意多个字符，而 ? 仅能匹配单个字符。例如： 1 2 3 <application name= \"*\" > <decor> no </decor> </application> 这样就去掉了所有窗口的边框。 Feh设置壁纸 Panels：tint2 配置透明效果 参考另一篇文章: openbox设置透明效果 dwm","tags":"Gentoo","title":"Gentoo安装详解（四）— 安装X桌面环境"},{"url":"http://wonux.github.io/gentoo-handbook-configure.html","text":"配置系统 系统信息： 文件系统信息： 创建/etc/fstab 1 nano -w /etc/fstab 网络信息： Host name, Domainname, etc 1 nano -w /etc/conf.d/hostname Configuring Network 1 nano -w /etc/conf.d/net 系统信息： Gentoo uses /etc/rc.conf to configure the services, startup, and shutdown of your system. 1 nano -w /etc/rc.conf Root Password 1 passwd Gentoo uses /etc/conf.d/hwclock to set clock options. 1 nano -w /etc/conf.d/hwclock 安装系统工具软件： 可选： PCMCIA 使用lspci查看硬件信息： 1 emerge pcmciautils System Logger： 1 2 emerge syslog-ng rc-update add syslog-ng default 可选：File Indexing： 1 emerge mlocate 可选：Remote Access： 1 rc-update add sshd default 可选： DHCP Client： 1 emerge dhcpcd 配置启动项： Using GRUB2 ： 1 2 emerge sys-boot/grub grub2-install /dev/sda Optionally, install theos-prober utility (provided through the sys-boot/os-prober package) to have GRUB2 probe for other operating systems when running thegrub2-mkconfig command. In most instances, this will enable GRUB2 to automatically detect other operating systems (Windows 7, Windows 8.1, etc.). Generating GRUB2 configuration： 1 grub2-mkconfig -o /boot/grub/grub.cfg 可选：Using GRUB Legacy： 1 emerge sys-boot/grub:0 编辑配置文件： 1 nano -w /boot/grub/grub.conf Example grub.conf： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # 默认选择哪个列表来引导。0表示第一个， 1表示第二个，以此类推。 default 0 # 引导默认列表前等待多少秒 timeout 30 # 使用漂亮、\"臃肿\"的spalsh图像来增加一点趣味:) # 如果您没有安装显卡，请将这行注释掉 splashimage=(hd0,0)/boot/grub/splash.xpm.gz title Gentoo Linux 3.10.10 # 内核镜像（或者操作系统）所在分区 root (hd0,0) kernel /boot/kernel-3.10.10-gentoo root=/dev/sda2 title Gentoo Linux 3.10.10 (rescue) # 内核镜像（或者操作系统）所在分区 root (hd0,0) kernel /boot/kernel-3.10.10-gentoo root=/dev/sda2 init=/bin/bb # 接下来的四行只有在您与Windows系统进行双启动的情况下才需要。 # 本例中，windows系统位于/dev/sda6。 title Windows XP rootnoverify (hd0,5) makeactive chainloader +1 #win7下注释掉makeactive Setting up GRUB Legacy using grub-install: Creating /etc/mtab: 1 grep -v rootfs /proc/mounts > /etc/mtab Install GRUB Legacy: 1 grub-install --no-floppy /dev/sda 重启系统: 1 2 3 4 5 exit cd umount -l /mnt/gentoo/dev{/shm,/pts,} umount -l /mnt/gentoo{/boot,/proc,} reboot","tags":"Gentoo","title":"Gentoo安装详解（三）— 配置系统"},{"url":"http://wonux.github.io/gentoo-handbook-kernel.html","text":"编译内核： 安装内核源码： 选择内核：如gentoo-sources 1 2 emerge gentoo-sources ls -l /usr/src/linux 手动编译内核： 1 2 cd /usr/src/linux make menuconfig 必须启用的选项： Most information can be gathered by emerging sys-apps/pciutils which contains the lspci command: 显卡： Xorg/Configuration 声卡： ALSA 网卡：根据具体网卡芯片型号，查看wiki。 无线网卡芯片驱动查询： Linux Wireless 其他选项根据需要添加，不了解保持默认即可. 编译内核与模块： 1 make && make modules_install 拷贝内核到启动分区： 1 2 3 cp arch/x86_64/boot/bzImage /boot/kernel-3.10.10-gentoo 或 make install #使用make install This will copy the kernel image into /boot together with the System.map file and the kernel configuration file. 使用genkernel编译内核： 1 emerge genkernel 可选：复制安装光盘上的内核配置文件： 1 zcat /proc/config.gz > /usr/share/genkernel/arch/x86_64/kernel-config 编译： 1 genkernel --menuconfig all 一旦genkernel运行完成，一个包括全部模块和initrd的内核将被建立。在后面配置引导程序时我们将会用到这个内核和initrd。请记下内核和initrd的名字，因为您将在配置引导程序的时候用到他们(Grub Legacy使用)。initrd将会在启动真正的系统前自动识别硬件（如同安装光盘一样）。 1 ls /boot/kernel* /boot/initramfs*","tags":"Gentoo","title":"Gentoo安装详解（二）— 编译内核"},{"url":"http://wonux.github.io/gentoo-handbook-base.html","text":"前期准备 远程登录： 开启ssh服务： 1 /etc/init.d/sshd start 设置密码： \"` passwd 1 2 3 4 5 以便使用putty、ssh client远程登录上传stage等（有时在线下载很慢，而局域网上传很快） ### 准备磁盘： - 分区： fdisk /dev/sda 1 2 3 4 5 6 > /dev/sda1 : /boot 100M(32-100M) 设启动笔记-a /dev/sda2 : / 20G /dev/sda3 : /home 20G /dev/sda5 : /swap 1G (内存< 512 MB,分区分配2倍内存大小的空间;> 1024 MB，可以分配较少的空间甚至不需要swap 分区。)-t 82 - 创建文件系统： mkfs.ext4 /dev/sda1 mkfs.ext4 /dev/sda2 mkfs.ext4 /dev/sda3 mkswap /dev/sda5 1 - 挂载分区： mount /dev/sda2 /mnt/gentoo mkdir /mnt/gentoo/boot mount /dev/sda1 /mnt/gentoo/boot mkdir /mnt/gentoo/home mount /dev/sda3 /mnt/gentoo/home swapon /dev/sda5 1 2 3 4 5 ## 安装系统 ### 安装stage及portage： - 正确设置日期／时间： date 1 2 3 > 如果显示的日期／时间不正确，可以使用date MMDDhhmmYYYY命令 - 下载Stage3 Tarbll： cd /mnt/gentoo links http://www.gentoo.org/main/en/mirrors.xml 1 2 3 4 选择国内速度较快的镜像，进入releases/x86/autobuilds/目录里。你将会看到所有适合你的计算机体系结构的stage文件（它们也可能放在各个独立的子体系名称的子目录里）。选择一个，然后按D来下载。下载完以后，再按Q退出浏览器。 > 或使用SSH Secure Shell登录上传stage3文件 - 解开Stage3 Tarball： tar xvjpf stage3-*.tar.bz2 1 2 - 下载Portage： 打开links（或者lynx）然后到我们的Gentoo镜像列表。选择一个离你最近的镜像，打开snapshots/目录。然后选择最新的Portage快照（portage-latest.tar.bz2）并按D来下载它。 links http://www.gentoo.org/main/en/mirrors.xml 1 2 3 > 或使用SSH Secure Shell登录上传portage文件 - 解压Portage： tar -xvjf /mnt/gentoo/portage-latest.tar.bz2 -C /mnt/gentoo/usr （install a Portage snapshot） 1 2 3 ### 编译前准备： - 配置编译选项： nano -w /mnt/gentoo/etc/portage/make.conf 1 2 3 4 5 > CFLAGS=\"-march=native -O2 -pipe\" CXXFLAGS=\" ${ CFLAGS } \" # 两个变量使用相同的设置 MAKEOPTS=\"-j3\" #MAKEOPTS定义在安装软件的时候同时可以产生并行编译的数目，CPU数目加一是个不错的选择 查看cpu信息： cat proc/cpuinfo 1 2 3 4 - 选择镜像站点： ``` mirrorselect -i -o >> /mnt/gentoo/etc/portage/make.conf mirrorselect -i -r -o >> /mnt/gentoo/etc/portage/make.conf Warning: app-portage/mirrorselect has not been updated to handle modifying the target chrootsrepos.conf/gentoo.conf file yet. Also, the SYNC variable in make.conf is deprecated and no longer used by portage. This section needs to be updated, please skip for the time being… 拷贝 DNS 信息： 1 cp -L /etc/resolv.conf /mnt/gentoo/etc/ Chroot进入新系统环境： Chroot： 挂载 /proc, /dev, /sys文件系统： 1 2 3 mount -t proc none /mnt/gentoo/proc mount --rbind /dev /mnt/gentoo/dev mount --rbind /sys /mnt/gentoo/sys 进入新的系统环境： 1 2 3 chroot /mnt/gentoo /bin/bash source /etc/profile export PS1=\"(chroot) $ PS1 \" 新环境配置： 更新portage树： 1 2 3 emerge --sync （Updating the Portage tree） 或 emerge-webrsync（fetch the latest portage snapshot） 选择Profile： 1 2 eselect profile list eselect profile set × 设置时区： 1 2 3 ls /usr/share/zoneinfo echo \"Europe/Brussels\" > /etc/timezone emerge --config sys-libs/timezone-data 设置locale： 1 2 3 4 nano -w /etc/locale.gen locale-gen eselect locale list eselect locale set x 更新环境变量： 1 env-update && source /etc/profile","tags":"Gentoo","title":"Gentoo安装详解（一）— 安装基本系统"}]}